#include "../../foundation/window.h"
#include "../../graphics/buffer.h"
#include "../../graphics/buffer_ext.h"
#include "../../graphics/image.h"
#include "../../graphics/renderpass.h"
#include "../../graphics/shader.h"
#include "../../graphics/font.h"
#include "../../graphics/material.h"
#include "../../graphics/model.h"
#include "../../graphics/swapchain.h"
#include "../../graphics/window.h"
#include "../world_private.h"
#include "../components/element_private.h"
#include "../components/node_private.h"
#include "../components/camera_private.h"
#include "renderer_private.h"

namespace flame
{
	using namespace graphics;

	struct ElementVertex
	{
		vec2 pos;
		vec2 uv;
		cvec4 col;
	};

	struct MeshVertex
	{
		vec3 pos;
		vec2 uv;
		vec3 normal;
	};

	struct ArmMeshVertex : MeshVertex
	{
		ivec4 ids;
		vec4 weights;
	};

	struct ParticleVertex
	{
		vec3 pos;
		vec3 xext;
		vec3 yext;
		vec4 uv;
		vec4 col;
	};

	struct ElementDrawCmd
	{
		uint res;
		std::vector<ElementVertex> vertices;
		std::vector<uint> indices;
		Rect scissor;
	};

	struct MaterialPipeline
	{
		std::filesystem::path mat;
		std::vector<std::string> defines;
		uint ref_count = 1;
		std::unique_ptr<Pipeline> pipeline;
	};

	struct MaterialRes
	{
		Material* mat;
		bool opaque;
		bool sort;
		std::filesystem::path pipeline_file;
		std::vector<std::string> pipeline_defines;
		int texs[MaxMaterialTexturesCount];
		Pipeline* pls[MaterialUsageCount] = {};

		Pipeline* get_pl(sRendererPrivate* thiz, MaterialUsage u);
	};

	struct ElemenetRenderData
	{
		bool should_render;

		std::vector<ImageView*> reses;

		Rect						scissor;
		std::vector<ElementDrawCmd> layers[128];
		uint						max_layer = 0;

		SequentialBuffer<ElementVertex>	buf_vtx;
		SequentialBuffer<uint>			buf_idx;
		std::unique_ptr<DescriptorSet>			ds_element;

		Pipeline* pl_element;
	};

	enum MaterialType
	{
		MaterialWireframe,
		MaterialOutline,
		MaterialPickup,
		MaterialNormalData,
		MaterialCustom,
		MaterialTypeCount
	};

	const inline auto MsaaSampleCount = SampleCount_4;
	const inline uint MaxMatCount = _countof(DSL_material::MaterialInfos::material_infos);
	const inline uint MaxTrnMatCount = 16;
	const inline uint TrnMatBase = MaxMatCount - MaxTrnMatCount;

	struct NodeRenderData
	{
		bool should_render;

		float min_log_lum = -5.f;
		float max_log_lum = +5.f;
		float white_point = 4.f;
		float gamma = 2.2f;
		uint dir_shadow_levels = 3U;
		float dir_shadow_dist = 100.f;
		float pt_shadow_dist = 20.f;
		float pt_shadow_near = 0.1f;
		float ssao_radius = 0.5f;
		float ssao_bias = 0.025f;

		std::vector<ImageView*> tex_reses;
		std::vector<MaterialRes> mat_reses;
		uint max_opq_mat_id = 0;
		uint max_trn_mat_id = 0;

		std::vector<std::pair<uint, mat3>>				dir_shadows;
		std::vector<std::pair<uint, vec3>>				pt_shadows;
		std::vector<std::vector<std::pair<uint, uint>>>	meshes[MaterialMeshUsageCount];
		std::vector<std::pair<uint, uint>>				terrains[MaterialTypeCount];
		std::vector<std::pair<uint, uint>>				waters[MaterialTypeCount];
		std::vector<std::pair<uint, uint>>				particles;

		SequentialBuffer<DrawIndexedIndirectCommand> buf_mesh_indirs[MaterialMeshUsageCount];

		SparseBuffer<MeshVertex>	buf_mesh_vtx;
		SparseBuffer<uint>			buf_mesh_idx;
		SparseBuffer<ArmMeshVertex>	buf_arm_mesh_vtx;
		SparseBuffer<uint>			buf_arm_mesh_idx;

		StorageBuffer<DSL_render_data::RenderData>							buf_render_data;
		std::unique_ptr<DescriptorSet>										ds_render_data;
		ArrayStorageBuffer<DSL_material::MaterialInfos>						buf_materials;
		std::unique_ptr<DescriptorSet>										ds_material;
		SequentialArrayStorageBuffer<mesh::DSL_mesh::Transforms>			buf_mesh_transforms;
		SequentialArrayStorageBuffer<mesh::DSL_mesh::Armatures>				buf_mesh_armatures;
		std::unique_ptr<DescriptorSet>										ds_mesh;
		SequentialArrayStorageBuffer<terrain::DSL_terrain::TerrainInfos>	buf_terrain;
		std::unique_ptr<DescriptorSet>										ds_terrain;
		SequentialArrayStorageBuffer<water::DSL_water::WaterInfos>			buf_water;
		std::unique_ptr<DescriptorSet>										ds_water;

		std::unique_ptr<Image> img_dep;
		std::unique_ptr<Image> img_col_met;	// color, metallic
		std::unique_ptr<Image> img_nor_rou;	// normal, roughness
		std::unique_ptr<Image> img_ao;		// ambient occlusion
		std::unique_ptr<Image> img_ao_back;
		std::unique_ptr<Image> img_col_ms;
		std::unique_ptr<Image> img_dep_ms;
		std::unique_ptr<Image> img_dst_back;
		std::unique_ptr<Image> img_dep_back;

		SequentialArrayStorageBuffer<DSL_light::LightInfos>		buf_light_infos;
		ArrayStorageBuffer<DSL_light::TileLightsMap>			buf_tile_lights;
		SequentialArrayStorageBuffer<DSL_light::DirShadows>		buf_dir_shadows;
		SequentialArrayStorageBuffer<DSL_light::PtShadows>		buf_pt_shadows;
		std::vector<std::unique_ptr<Image>>						img_dir_shadow_maps;
		std::vector<std::unique_ptr<Image>>						img_pt_shadow_maps;
		std::unique_ptr<DescriptorSet>							ds_light;

		PipelineLayout* pll_mesh_fwd;
		PipelineLayout* pll_mesh_gbuf;
		PipelineLayout* pll_terrain_fwd;
		PipelineLayout* pll_terrain_gbuf;
		PipelineLayout* pll_water;
		PipelineLayout* pll_post;

		std::unique_ptr<Framebuffer> fb_gbuf;
		std::vector<std::unique_ptr<Framebuffer>> fb_tars_dep;
		std::unique_ptr<Framebuffer> fb_fwd_ms4;

		std::vector<MaterialPipeline> pl_mats[MaterialUsageCount];

		StorageBuffer<DSL_ssao::SampleLocations>	buf_ssao_loc;
		StorageBuffer<DSL_ssao::SampleNoises>		buf_ssao_noi;
		Pipeline*									pl_ssao;
		Pipeline*									pl_ssao_blur;
		std::unique_ptr<DescriptorSet>						ds_ssao;

		Pipeline*				pl_def;
		std::unique_ptr<DescriptorSet>	ds_def;

		SequentialBuffer<ParticleVertex>	buf_ptc_vtx;
		Pipeline* pl_ptc;

		Pipeline* pl_blit_rgba8;
		Pipeline* pl_blit_rgba16;
		Pipeline* pl_blit_rgba16ms4;
		Pipeline* pl_blit_d16;
		Pipeline* pl_blit_d16ms4;
		Pipeline* pl_add_bgra8;
		Pipeline* pl_add_rgba8;
		Pipeline* pl_add_rgba16;
		Pipeline* pl_fxaa;
		Pipeline* pl_downsample;
		Pipeline* pl_upsample;

		StorageBuffer<DSL_luminance::Histogram>		buf_lum_htg;
		StorageBuffer<DSL_luminance::AverageLum>	buf_lum_avg;
		std::unique_ptr<DescriptorSet>						ds_lum;
		PipelineLayout* pll_lum;
		Pipeline* pl_lum_htg;
		Pipeline* pl_lum_avg;

		Pipeline* pl_bright;

		Pipeline* pl_tone;
		std::unique_ptr<DescriptorSet>	ds_tone;

		SequentialBuffer<Line>	buf_lines;
		Pipeline* pl_line;

		NodeRenderData()
		{
			particles.emplace_back(0xffff, 0);
		}
	};

	sRendererPrivate::sRendererPrivate()
	{
		_ed.reset(new ElemenetRenderData);
		_nd.reset(new NodeRenderData);
	}

	sRendererPrivate::~sRendererPrivate()
	{
		Queue::get(nullptr)->wait_idle();
	}

	uint sRendererPrivate::element_render(uint layer, cElementPrivate* element)
	{
		auto& ed = *_ed;

		auto e = element->entity;

		if (element->layer_policy == 2)
			element->layer_policy = 0;

		element->parent_scissor = ed.scissor;
		element->update_transform();
		auto culled = !ed.scissor.overlapping(element->bounds);
		if (element->culled != culled)
		{
			element->culled = culled;
			element->data_changed("culled"_h);
		}
		if (culled)
			return layer;

		auto self_transparent = true;
		if (!element->draw(layer))
			self_transparent = false;

		auto clipping = false;
		Rect last_scissor;
		if (element->clipping && !(ed.scissor == element->bounds))
		{
			element->layer_policy = 2;

			clipping = true;
			last_scissor = ed.scissor;
			ed.scissor = element->bounds;
			layer = ed.max_layer;
			auto& info = ed.layers[layer].emplace_back();
			info.scissor = ed.scissor;
		}

		if (!element->drawers.empty())
		{
			auto l = layer;
			for (auto d : element->drawers)
				layer = max(layer, d->draw(l, this));
			self_transparent = false;
		}

		if (!self_transparent)
			layer++;
		ed.max_layer = max(ed.max_layer, layer);
		auto children_max_layer = layer;
		for (auto& c : e->children)
		{
			if (!c->global_visibility)
				continue;

			auto celement = c->get_component_i<cElementPrivate>(0);
			if (celement)
			{
				children_max_layer = max(children_max_layer, element_render(layer, celement));
				if (celement->layer_policy > 0)
				{
					layer = children_max_layer;
					if (celement->layer_policy == 2)
						element->layer_policy = 2;
				}
			}
		}

		if (clipping)
		{
			ed.scissor = last_scissor;
			auto& info = ed.layers[children_max_layer].emplace_back();
			info.scissor = last_scissor;
		}

		return max(layer, children_max_layer);
	}

	void sRendererPrivate::node_render(cNodePrivate* node, Frustum* lod_frustums)
	{
		auto e = node->entity;

		node->update_transform();
		node->draw(frame, false);

		if (node->octree)
		{
			std::vector<cNodePrivate*> objs;
			node->octree->get_within_frustum(lod_frustums[node->octree_lod], objs);
			for (auto obj : objs)
				node_render(obj, lod_frustums);
		}
		else
		{
			for (auto& c : e->children)
			{
				if (!c->global_visibility)
					continue;

				auto cnode = c->get_component_i<cNodePrivate>(0);
				if (cnode)
					node_render(cnode, lod_frustums);
			}
		}
	}

	void sRendererPrivate::setup(Window* _window, bool external_targets)
	{
		assert(!window);
		window = _window;

		if (!external_targets)
		{
			auto set_targets_from_window = [this](const uvec2& size) {
				std::vector<ImageView*> views;

				auto swapchain = window->get_swapchain();
				views.resize(swapchain->get_images_count());
				for (auto i = 0; i < views.size(); i++)
					views[i] = swapchain->get_image(i)->get_view();

				set_targets(views);
			};

			set_targets_from_window(uvec2(0));

			window->get_native()->add_resize_listener(set_targets_from_window);
		}

		window->add_renderer([](Capture& c, uint img_idx, CommandBuffer* commandbuffer) {
			auto thiz = c.thiz<sRendererPrivate>();
			thiz->render(img_idx, commandbuffer);
		}, Capture().set_thiz(this));
	}

	void sRendererPrivate::set_targets(const std::vector<ImageView*>& views)
	{
		img_tars.resize(views.size());
		for (auto i = 0; i < views.size(); i++)
			img_tars[i] = views[i]->get_image();

		fb_tars.clear();
		fb_tars.resize(views.size());
		for (auto i = 0; i < views.size(); i++)
			fb_tars[i].reset(Framebuffer::create(rp_bgra8, 1, &views[i]));

		if (views.empty())
			return;

		tar_sz = views[0]->get_image()->get_size();
		auto hf_tar_sz = tar_sz / 2U;

		img_dst.reset(Image::create(nullptr, Format_R16G16B16A16_SFLOAT, tar_sz, 1, 1,
			SampleCount_1, ImageUsageSampled | ImageUsageAttachment | ImageUsageStorage));

		auto& nd = *_nd;

		nd.img_dep.reset(Image::create(nullptr, Format_Depth16, tar_sz, 1, 1,
			SampleCount_1, ImageUsageSampled | ImageUsageAttachment | ImageUsageTransferSrc));
		nd.img_col_met.reset(Image::create(nullptr, Format_R8G8B8A8_UNORM, tar_sz, 1, 1,
			SampleCount_1, ImageUsageSampled | ImageUsageAttachment));
		nd.img_nor_rou.reset(Image::create(nullptr, Format_R8G8B8A8_UNORM, tar_sz, 1, 1,
			SampleCount_1, ImageUsageSampled | ImageUsageAttachment));
		nd.img_ao.reset(Image::create(nullptr, Format_R8_UNORM, hf_tar_sz, 1, 1,
			SampleCount_1, ImageUsageSampled | ImageUsageAttachment));
		nd.img_col_ms.reset(Image::create(nullptr, Format_R16G16B16A16_SFLOAT, tar_sz, 1, 1,
			MsaaSampleCount, ImageUsageAttachment));
		nd.img_dep_ms.reset(Image::create(nullptr, Format_Depth16, tar_sz, 1, 1,
			MsaaSampleCount, ImageUsageAttachment));
		nd.img_dst_back.reset(Image::create(nullptr, Format_R16G16B16A16_SFLOAT, tar_sz, 0, 1,
			SampleCount_1, ImageUsageSampled | ImageUsageAttachment));
		nd.img_dep_back.reset(Image::create(nullptr, Format_Depth16, tar_sz, 1, 1,
			SampleCount_1, ImageUsageSampled | ImageUsageAttachment | ImageUsageTransferDst));
		nd.img_dep_back->change_layout(ImageLayoutUndefined, ImageLayoutShaderReadOnly);
		nd.img_ao_back.reset(Image::create(nullptr, Format_R8_UNORM, hf_tar_sz, 1, 1,
			SampleCount_1, ImageUsageSampled | ImageUsageAttachment));

		{
			ImageView* vs[] = {
				nd.img_col_met->get_view(),
				nd.img_nor_rou->get_view(),
				nd.img_dep->get_view()
			};
			nd.fb_gbuf.reset(Framebuffer::create(Renderpass::get(nullptr, L"gbuffer.rp"), countof(vs), vs));
		}

		nd.fb_tars_dep.clear();
		nd.fb_tars_dep.resize(views.size());
		auto rp_bgra8d16c = Renderpass::get(nullptr, L"bgra8d16c.rp");
		for (auto i = 0; i < views.size(); i++)
		{
			ImageView* vs[] = {
				views[i],
				nd.img_dep->get_view()
			};
			nd.fb_tars_dep[i].reset(Framebuffer::create(rp_bgra8d16c, countof(vs), vs));
		}

		{
			ImageView* vs[] = {
				nd.img_col_ms->get_view(),
				nd.img_dep_ms->get_view(),
				img_dst->get_view()
			};
			nd.fb_fwd_ms4.reset(Framebuffer::create(Renderpass::get(nullptr, L"forward_ms4.rp"), countof(vs), vs));
		}

		nd.ds_ssao->set_image(DSL_ssao::img_nor_rou_binding, 0, nd.img_nor_rou->get_view(), sp_nearest);
		nd.ds_ssao->set_image(DSL_ssao::img_dep_binding, 0, nd.img_dep->get_view(), sp_nearest);
		nd.ds_ssao->update();

		nd.ds_def->set_image(DSL_deferred::img_col_met_binding, 0, nd.img_col_met->get_view(), sp_nearest);
		nd.ds_def->set_image(DSL_deferred::img_nor_rou_binding, 0, nd.img_nor_rou->get_view(), sp_nearest);
		nd.ds_def->set_image(DSL_deferred::img_ao_binding, 0, nd.img_ao->get_view(), sp_nearest);
		nd.ds_def->set_image(DSL_deferred::img_dep_binding, 0, nd.img_dep->get_view(), sp_nearest);
		nd.ds_def->update();

		nd.ds_water->set_image(water::DSL_water::img_depth_binding, 0, nd.img_dep_back->get_view(), sp_nearest);
		nd.ds_water->update();

		nd.ds_lum->set_image(DSL_luminance::img_col_binding, 0, img_dst->get_view(), nullptr);
		nd.ds_lum->update();

		nd.ds_tone->set_image(DSL_tone::image_binding, 0, img_dst->get_view(), sp_nearest);
		nd.ds_tone->update();

		dirty = true;
	}

	void sRendererPrivate::get_shadow_props(uint* dir_levels, float* dir_dist, float* pt_dist)
	{
		auto& nd = *_nd;

		if (dir_levels)
			*dir_levels = nd.dir_shadow_levels;
		if (dir_dist)
			*dir_dist = nd.dir_shadow_dist;
		if (pt_dist)
			*pt_dist = nd.pt_shadow_dist;
	}

	void sRendererPrivate::set_shadow_props(uint dir_levels, float dir_dist, float pt_dist)
	{
		auto& nd = *_nd;

		nd.dir_shadow_levels = dir_levels;
		nd.dir_shadow_dist = dir_dist;
		nd.pt_shadow_dist = pt_dist;
	}

	void sRendererPrivate::get_ssao_props(float* radius, float* bias)
	{
		auto& nd = *_nd;

		if (radius)
			*radius = nd.ssao_radius;
		if (bias)
			*bias = nd.ssao_bias;
	}

	void sRendererPrivate::set_ssao_props(float radius, float bias)
	{
		auto& nd = *_nd;

		nd.ssao_radius = radius;
		nd.ssao_bias = bias;
	}

	ImageView* sRendererPrivate::get_element_res(uint idx) const
	{
		return _ed->reses[idx];
	}

	int sRendererPrivate::set_element_res(int idx, ImageView* iv, Sampler* sp)
	{
		auto iv_white = img_white->get_view();
		auto& ed = *_ed;

		if (!iv)
			iv = iv_white;

		if (idx == -1)
		{
			for (auto i = 1; i < ed.reses.size(); i++)
			{
				if (ed.reses[i] == iv_white)
				{
					idx = i;
					break;
				}
			}
		}
		if (idx == -1)
			return -1;

		ed.reses[idx] = iv;
		ed.ds_element->set_image(DescriptorSetLayout::get(nullptr, L"element/element.dsl")
			->find_binding("images"), idx, iv, sp ? sp : sp_linear);
		ed.ds_element->update();

		return idx;
	}

	int sRendererPrivate::find_element_res(ImageView* iv) const
	{
		auto& ed = *_ed;
		for (auto i = 0; i < ed.reses.size(); i++)
		{
			if (ed.reses[i] == iv)
				return i;
		}
		return -1;
	}

	void sRendererPrivate::fill(uint layer, uint pt_cnt, const vec2* pts, const cvec4& color)
	{
		if (pt_cnt == 0)
			return;

		auto& ed = *_ed;

		auto vtx_cnt = 3 * (pt_cnt - 2);
		auto idx_cnt = vtx_cnt;
		ed.buf_vtx.stag_num += vtx_cnt;
		ed.buf_idx.stag_num += idx_cnt;

		auto& info = ed.layers[layer].emplace_back();
		info.res = 0;
		info.vertices.resize(vtx_cnt);
		info.indices.resize(idx_cnt);

		auto off = 0;
		for (auto i = 0; i < pt_cnt - 2; i++)
		{
			info.vertices[off + 0] = { pts[0],		vec2(0.5f), color };
			info.vertices[off + 1] = { pts[i + 1],	vec2(0.5f), color };
			info.vertices[off + 2] = { pts[i + 2],	vec2(0.5f), color };

			info.indices[off + 0] = off + 0;
			info.indices[off + 1] = off + 2;
			info.indices[off + 2] = off + 1;

			off += 3;
		}
	}

	void sRendererPrivate::stroke(uint layer, uint pt_cnt, const vec2* pts, float thickness, const cvec4& color, bool closed)
	{
		if (pt_cnt == 0)
			return;

		auto& ed = *_ed;

		auto vtx_cnt = 2 * pt_cnt;
		auto idx_cnt = 6 * (pt_cnt - 1);
		if (closed)
			idx_cnt += 6;
		ed.buf_vtx.stag_num += vtx_cnt;
		ed.buf_idx.stag_num += idx_cnt;

		auto& info = ed.layers[layer].emplace_back();
		info.res = 0;
		info.vertices.resize(vtx_cnt);
		info.indices.resize(idx_cnt);

		auto get_normal = [](const vec2& p1, const vec2& p2) {
			auto d = normalize(p2 - p1);
			return vec2(d.y, -d.x);
		};

		auto vtx_off = 0;
		auto idx_off = 0;
		vec2 first_normal;
		vec2 last_normal;

		first_normal = last_normal = get_normal(pts[0], pts[1]);
		info.vertices[0] = { pts[0] + first_normal * thickness, vec2(0.5f), color };
		info.vertices[1] = { pts[0] - first_normal * thickness, vec2(0.5f), color };

		vtx_off += 2;
		for (auto i = 1; i < pt_cnt - 1; i++)
		{
			auto _n = get_normal(pts[i], pts[i + 1]);
			auto n = (last_normal + _n) * 0.5f;
			last_normal = _n;
			info.vertices[vtx_off + 0] = { pts[i] + n * thickness, vec2(0.5f), color };
			info.vertices[vtx_off + 1] = { pts[i] - n * thickness, vec2(0.5f), color };

			info.indices[idx_off + 0] = vtx_off - 2;
			info.indices[idx_off + 1] = vtx_off - 1;
			info.indices[idx_off + 2] = vtx_off + 1;
			info.indices[idx_off + 3] = vtx_off - 2;
			info.indices[idx_off + 4] = vtx_off + 1;
			info.indices[idx_off + 5] = vtx_off + 0;

			vtx_off += 2;
			idx_off += 6;
		}

		if (closed)
		{
			auto _n = get_normal(pts[pt_cnt - 1], pts[0]);
			auto n = (last_normal + _n) * 0.5f;

			info.vertices[vtx_off + 0] = { pts[pt_cnt - 1] + n * thickness, vec2(0.5f), color };
			info.vertices[vtx_off + 1] = { pts[pt_cnt - 1] - n * thickness, vec2(0.5f), color };

			info.indices[idx_off + 0] = vtx_off - 2;
			info.indices[idx_off + 1] = vtx_off - 1;
			info.indices[idx_off + 2] = vtx_off + 1;
			info.indices[idx_off + 3] = vtx_off - 2;
			info.indices[idx_off + 4] = vtx_off + 1;
			info.indices[idx_off + 5] = vtx_off + 0;

			vtx_off += 2;
			idx_off += 6;

			n = (_n + first_normal) * 0.5f;

			info.vertices[0] = { pts[0] + n * thickness, vec2(0.5f), color };
			info.vertices[1] = { pts[0] - n * thickness, vec2(0.5f), color };

			info.indices[idx_off + 0] = vtx_off - 2;
			info.indices[idx_off + 1] = vtx_off - 1;
			info.indices[idx_off + 2] = 1;
			info.indices[idx_off + 3] = vtx_off - 2;
			info.indices[idx_off + 4] = 1;
			info.indices[idx_off + 5] = 0;
		}
		else
		{
			info.vertices[vtx_off + 0] = { pts[pt_cnt - 1] + last_normal * thickness, vec2(0.5f), color };
			info.vertices[vtx_off + 1] = { pts[pt_cnt - 1] - last_normal * thickness, vec2(0.5f), color };

			info.indices[idx_off + 0] = vtx_off - 2;
			info.indices[idx_off + 1] = vtx_off - 1;
			info.indices[idx_off + 2] = vtx_off + 1;
			info.indices[idx_off + 3] = vtx_off - 2;
			info.indices[idx_off + 4] = vtx_off + 1;
			info.indices[idx_off + 5] = vtx_off + 0;

			vtx_off += 2;
			idx_off += 6;
		}
	}

	void sRendererPrivate::draw_glyphs(uint layer, uint cnt, const GlyphDraw* glyphs, uint res_id, const cvec4& color)
	{
		if (cnt == 0)
			return;

		auto& ed = *_ed;

		auto vtx_cnt = 4 * cnt;
		auto idx_cnt = 6 * cnt;
		ed.buf_vtx.stag_num += vtx_cnt;
		ed.buf_idx.stag_num += idx_cnt;

		auto& info = ed.layers[layer].emplace_back();
		info.res = res_id;
		info.vertices.resize(vtx_cnt);
		info.indices.resize(idx_cnt);

		auto vtx_off = 0;
		auto idx_off = 0;
		for (auto i = 0; i < cnt; i++)
		{
			auto& g = glyphs[i];

			info.vertices[vtx_off + 0] = { g.points[0],	g.uvs.xy(), color };
			info.vertices[vtx_off + 1] = { g.points[1],	g.uvs.xw(), color };
			info.vertices[vtx_off + 2] = { g.points[2],	g.uvs.zw(), color };
			info.vertices[vtx_off + 3] = { g.points[3],	g.uvs.zy(), color };

			info.indices[idx_off + 0] = vtx_off + 0;
			info.indices[idx_off + 1] = vtx_off + 2;
			info.indices[idx_off + 2] = vtx_off + 1;
			info.indices[idx_off + 3] = vtx_off + 0;
			info.indices[idx_off + 4] = vtx_off + 3;
			info.indices[idx_off + 5] = vtx_off + 2;

			vtx_off += 4;
			idx_off += 6;
		}
	}

	void sRendererPrivate::draw_image(uint layer, const vec2* pts, uint res_id, const vec4& uvs, const cvec4& tint_color)
	{
		auto& ed = *_ed;

		ed.buf_vtx.stag_num += 4;
		ed.buf_idx.stag_num += 6;

		auto& info = ed.layers[layer].emplace_back();
		info.res = res_id;
		info.vertices.resize(4);
		info.indices.resize(6);

		info.vertices[0] = { pts[0], uvs.xy(), tint_color };
		info.vertices[1] = { pts[1], uvs.zy(), tint_color };
		info.vertices[2] = { pts[2], uvs.zw(), tint_color };
		info.vertices[3] = { pts[3], uvs.xw(), tint_color };

		info.indices[0] = 0;
		info.indices[1] = 2;
		info.indices[2] = 1;
		info.indices[3] = 0;
		info.indices[4] = 3;
		info.indices[5] = 2;
	}

	int sRendererPrivate::set_texture_res(int idx, ImageView* tex, Sampler* sp)
	{
		auto& nd = *_nd;

		if (idx == -1)
		{
			for (auto i = 0; i < nd.tex_reses.size(); i++)
			{
				if (!nd.tex_reses[i])
				{
					idx = i;
					break;
				}
			}
		}
		if (idx == -1)
			return -1;

		nd.tex_reses[idx] = tex;
		nd.ds_material->set_image(DSL_material::maps_binding, idx, tex ? tex : img_white->get_view(), sp ? sp : sp_linear);
		nd.ds_material->update();

		return idx;
	}

	int sRendererPrivate::find_texture_res(ImageView* tex) const
	{
		auto& nd = *_nd;
		for (auto i = 0; i < nd.tex_reses.size(); i++)
		{
			if (nd.tex_reses[i] == tex)
				return i;
		}
		return -1;
	}

	Pipeline* MaterialRes::get_pl(sRendererPrivate* thiz, MaterialUsage u)
	{
		if (pls[u])
			return pls[u];
		pls[u] = thiz->get_material_pipeline(u, pipeline_file, pipeline_defines);
		return pls[u];
	}

	bool parse_define(const std::vector<std::string>& defines, std::string_view n, std::string& v)
	{
		for (auto& d : defines)
		{
			if (d.compare(0, n.size(), n) == 0)
			{
				if (d.size() == n.size())
					return true;
				if (d[n.size()] == '=')
				{
					v = d.substr(n.size() + 1);
					return true;
				}
			}
		}
		return false;
	};

	Pipeline* sRendererPrivate::get_material_pipeline(MaterialUsage usage, const std::filesystem::path& mat, std::vector<std::string> defines)
	{
		auto& nd = *_nd;

		for (auto& p : nd.pl_mats[usage])
		{
			if (p.mat == mat && p.defines == defines)
			{
				p.ref_count++;
				return p.pipeline.get();
			}
		}

		Pipeline* ret = nullptr;

		std::vector<std::pair<std::string, std::string>> substitutes;
		auto polygon_mode = PolygonModeFill;
		auto cull_mode = CullModeBack;
		auto a2c = false;
		auto depth_test = true;
		auto depth_write = true;
		auto use_mat = true;
		auto deferred = true;
		auto alpha_blend = false;

		Renderpass* rp = nullptr;

		std::string str;
		if (parse_define(defines, "WIREFRAME", str))
		{
			use_mat = false;
			polygon_mode = PolygonModeLine;
			depth_test = false;
			depth_write = false;
			deferred = false;
			rp = Renderpass::get(nullptr, L"bgra8l.rp");
		}
		else if (parse_define(defines, "PICKUP", str))
		{
			use_mat = false;
			deferred = false;
			rp = Renderpass::get(nullptr, L"rgba16.rp");
		}
		else if (parse_define(defines, "OUTLINE", str))
		{
			use_mat = false;
			depth_test = false;
			depth_write = false;
			deferred = false;
			rp = Renderpass::get(nullptr, L"rgba16.rp");
		}
		else if (parse_define(defines, "NORMAL_DATA", str))
		{
			use_mat = false;
			deferred = false;
			rp = Renderpass::get(nullptr, L"bgra8d16c.rp");
		}
		if (parse_define(defines, "TRANSPARENT", str))
		{
			deferred = false;
			if (parse_define(defines, "ALPHA_TEST", str))
				a2c = true;
			else
				alpha_blend = true;
		}
		if (use_mat && !mat.empty())
		{
			defines.push_back("MAT");
			substitutes.emplace_back("MAT_FILE", mat.string());
		}

		auto get_defines_str = [&]() {
			std::string ret;
			for (auto& t : defines)
			{
				ret += t;
				ret += ' ';
			}
			return ret;
		};

		auto get_substitutes_str = [&]() {
			std::string ret;
			for (auto& t : substitutes)
			{
				ret += t.first;
				ret += ' ';
				ret += t.second;
				ret += ' ';
			}
			return ret;
		};

		switch (usage)
		{
		case MaterialForMeshShadow:
			deferred = false;
			defines.push_back("SHADOW_PASS");
			rp = Renderpass::get(nullptr, L"d16.rp");
			alpha_blend = false;
		case MaterialForMesh:
		{
			if (deferred)
				defines.push_back("DEFERRED");
			auto defines_str = get_defines_str();
			auto substitutes_str = get_substitutes_str();
			GraphicsPipelineInfo info;
			Shader* shaders[] = {
				Shader::get(nullptr, L"mesh/mesh.vert", defines_str.c_str(), substitutes_str.c_str()),
				Shader::get(nullptr, L"mesh/mesh.frag", defines_str.c_str(), substitutes_str.c_str())
			};
			info.shaders_count = countof(shaders);
			info.shaders = shaders;
			info.layout = PipelineLayout::get(nullptr, deferred ? L"mesh/gbuffer.pll" : L"mesh/forward.pll");
			if (!rp)
			{
				if (deferred)
					rp = Renderpass::get(nullptr, L"gbuffer.rp");
				else
				{
					rp = Renderpass::get(nullptr, L"forward_ms4.rp");
					info.sample_count = MsaaSampleCount;
				}
			}
			info.renderpass = rp;
			info.subpass_index = 0;
			VertexAttributeInfo vias[3];
			vias[0].location = 0;
			vias[0].format = Format_R32G32B32_SFLOAT;
			vias[1].location = 1;
			vias[1].format = Format_R32G32_SFLOAT;
			vias[2].location = 2;
			vias[2].format = Format_R32G32B32_SFLOAT;
			VertexBufferInfo vib;
			vib.attributes_count = countof(vias);
			vib.attributes = vias;
			info.vertex_buffers_count = 1;
			info.vertex_buffers = &vib;
			info.polygon_mode = polygon_mode;
			info.cull_mode = cull_mode;
			info.alpha_to_coverage = a2c;
			info.depth_test = depth_test;
			info.depth_write = depth_write;
			BlendOption bo = { true, BlendFactorSrcAlpha, BlendFactorOneMinusSrcAlpha, BlendFactorOne, BlendFactorZero };
			if (alpha_blend)
			{
				info.blend_options_count = 1;
				info.blend_options = &bo;
			}
			ret = Pipeline::create(nullptr, info);
		}
			break;
		case MaterialForMeshShadowArmature:
			deferred = false;
			defines.push_back("SHADOW_PASS");
			rp = Renderpass::get(nullptr, L"d16.rp");
			alpha_blend = false;
		case MaterialForMeshArmature:
		{
			if (deferred)
				defines.push_back("DEFERRED");
			defines.push_back("ARMATURE");
			auto defines_str = get_defines_str();
			auto substitutes_str = get_substitutes_str();
			GraphicsPipelineInfo info;
			Shader* shaders[] = {
				Shader::get(nullptr, L"mesh/mesh.vert", defines_str.c_str(), substitutes_str.c_str()),
				Shader::get(nullptr, L"mesh/mesh.frag", defines_str.c_str(), substitutes_str.c_str())
			};
			info.shaders_count = countof(shaders);
			info.shaders = shaders;
			info.layout = PipelineLayout::get(nullptr, deferred ? L"mesh/gbuffer.pll" : L"mesh/forward.pll");
			if (!rp)
			{
				if (deferred)
					rp = Renderpass::get(nullptr, L"gbuffer.rp");
				else
				{
					rp = Renderpass::get(nullptr, L"forward_ms4.rp");
					info.sample_count = MsaaSampleCount;
				}
			}
			info.renderpass = rp;
			info.subpass_index = 0;
			VertexAttributeInfo vias[5];
			vias[0].location = 0;
			vias[0].format = Format_R32G32B32_SFLOAT;
			vias[1].location = 1;
			vias[1].format = Format_R32G32_SFLOAT;
			vias[2].location = 2;
			vias[2].format = Format_R32G32B32_SFLOAT;
			vias[3].location = 3;
			vias[3].format = Format_R32G32B32A32_INT;
			vias[4].location = 4;
			vias[4].format = Format_R32G32B32A32_SFLOAT;
			VertexBufferInfo vib;
			vib.attributes_count = countof(vias);
			vib.attributes = vias;
			info.vertex_buffers_count = 1;
			info.vertex_buffers = &vib;
			info.polygon_mode = polygon_mode;
			info.cull_mode = cull_mode;
			info.alpha_to_coverage = a2c;
			info.depth_test = depth_test;
			info.depth_write = depth_write;
			if (alpha_blend)
			{
				BlendOption bo = { true, BlendFactorSrcAlpha, BlendFactorOneMinusSrcAlpha, BlendFactorOne, BlendFactorZero };
				info.blend_options_count = 1;
				info.blend_options = &bo;
			}
			ret = Pipeline::create(nullptr, info);
		}
			break;
		case MaterialForTerrain:
		{
			if (deferred)
				defines.push_back("DEFERRED");
			auto defines_str = get_defines_str();
			auto substitutes_str = get_substitutes_str();
			GraphicsPipelineInfo info;
			Shader* shaders[] = {
				Shader::get(nullptr, L"terrain/terrain.vert", defines_str.c_str(), substitutes_str.c_str()),
				Shader::get(nullptr, L"terrain/terrain.tesc", defines_str.c_str(), substitutes_str.c_str()),
				Shader::get(nullptr, L"terrain/terrain.tese", defines_str.c_str(), substitutes_str.c_str()),
				Shader::get(nullptr, L"terrain/terrain.frag", defines_str.c_str(), substitutes_str.c_str())
			};
			info.shaders_count = countof(shaders);
			info.shaders = shaders;
			info.layout = PipelineLayout::get(nullptr, deferred ? L"terrain/gbuffer.pll" : L"terrain/forward.pll");
			if (!rp)
			{
				if (deferred)
					rp = Renderpass::get(nullptr, L"gbuffer.rp");
				else
				{
					rp = Renderpass::get(nullptr, L"forward_ms4.rp");
					info.sample_count = MsaaSampleCount;
				}
			}
			info.renderpass = rp;
			info.subpass_index = 0;
			info.primitive_topology = PrimitiveTopologyPatchList;
			info.patch_control_points = 4;
			info.polygon_mode = polygon_mode;
			info.cull_mode = cull_mode;
			info.depth_test = depth_test;
			info.depth_write = depth_write;
			ret = Pipeline::create(nullptr, info);
		}
			break;
		case MaterialForWater:
		{
			auto defines_str = get_defines_str();
			auto substitutes_str = get_substitutes_str();
			GraphicsPipelineInfo info;
			Shader* shaders[] = {
				Shader::get(nullptr, L"water/water.vert", defines_str.c_str(), substitutes_str.c_str()),
				Shader::get(nullptr, L"water/water.frag", defines_str.c_str(), substitutes_str.c_str())
			};
			info.shaders_count = countof(shaders);
			info.shaders = shaders;
			info.layout = PipelineLayout::get(nullptr, L"water/water.pll");
			if (!rp)
			{
				rp = Renderpass::get(nullptr, L"forward_ms4.rp");
				info.sample_count = MsaaSampleCount;
			}
			info.renderpass = rp;
			info.subpass_index = 0;
			info.primitive_topology = PrimitiveTopologyTriangleList;
			info.polygon_mode = polygon_mode;
			info.cull_mode = cull_mode;
			info.depth_test = depth_test;
			info.depth_write = false;
			info.blend_options_count = 1;
			BlendOption bo = { true, BlendFactorOne, BlendFactorSrcAlpha, BlendFactorOne, BlendFactorZero };
			info.blend_options = &bo;
			ret = Pipeline::create(nullptr, info);
		}
			break;
		}

		MaterialPipeline mp;
		mp.mat = mat;
		mp.defines = defines;
		mp.pipeline.reset(ret);
		nd.pl_mats[usage].push_back(std::move(mp));
		return ret;
	}

	void sRendererPrivate::release_material_pipeline(MaterialUsage usage, Pipeline* pl)
	{
		assert(0);

		auto& nd = *_nd;
		for (auto it = nd.pl_mats[usage].begin(); it != nd.pl_mats[usage].end(); it++)
		{
			// TODO: fix this (requires that all kinds of graphics resources are able to destroy when ref_count==0)
			//if (it->pipeline.get() == pl)
			//{
			//	for (auto s : p->shaders)
			//		s->release();
			//	if (it->ref_count == 1)
			//		material_pipelines[usage].erase(it);
			//	else
			//		it->ref_count--;
			//	break;
			//}
		}
	}

	void sRendererPrivate::set_sky(ImageView* box, ImageView* irr,
		ImageView* rad, ImageView* lut, const vec3& fog_color, float intensity, void* id)
	{
		sky_id = id;

		auto& nd = *_nd;

		auto iv_black = img_black->get_view();
		auto iv_black_cube = img_black_cube->get_view({ 0, 1, 0, 6 });
		nd.ds_light->set_image(DSL_light::sky_box_binding, 0, box ? box : iv_black_cube, sp_linear);
		nd.ds_light->set_image(DSL_light::sky_irr_binding, 0, irr ? irr : iv_black_cube, sp_linear);
		nd.ds_light->set_image(DSL_light::sky_rad_binding, 0, rad ? rad : iv_black_cube, sp_linear);
		nd.ds_light->set_image(DSL_light::sky_lut_binding, 0, lut ? lut : iv_black, sp_linear);
		nd.ds_light->update();

		auto& data = *nd.buf_render_data.pstag;
		data.fog_color = fog_color;
		data.sky_intensity = intensity;
		data.sky_rad_levels = rad->get_sub().level_count - 1;
	}

	uint sRendererPrivate::add_light(const mat4& mat, LightType type, const vec3& color, bool cast_shadow)
	{
		auto& nd = *_nd;

		auto idx = nd.buf_light_infos.n;

		// TODO
		{
			auto& data = nd.buf_light_infos.add_item();
			data.color = color;
			data.type = type;
			data.shadow_index = -1;

			auto& tile = nd.buf_tile_lights.item(0, false);
			switch (type)
			{
			case LightDirectional:
			{
				auto rot = mat3(mat);
				data.pos = -rot[2];
				if (tile.dir_count < countof(tile.dir_indices))
				{
					tile.dir_indices[tile.dir_count] = idx;
					tile.dir_count++;
				}
				if (cast_shadow)
				{
					if (nd.dir_shadows.size() < 4)
					{
						data.shadow_index = nd.dir_shadows.size();
						nd.dir_shadows.emplace_back(idx, rot);
					}
				}
			}
			break;
			case LightPoint:
			{
				auto pos = vec3(mat[3]);
				data.pos = pos;
				if (tile.pt_count < countof(tile.pt_indices))
				{
					tile.pt_indices[tile.pt_count] = idx;
					tile.pt_count++;
				}
				if (cast_shadow)
				{
					if (nd.pt_shadows.size() < 4)
					{
						data.shadow_index = nd.pt_shadows.size();
						nd.pt_shadows.emplace_back(idx, pos);
					}
				}
			}
			break;
			}
		}

		return idx;
	}

	mat4 sRendererPrivate::get_shaodw_mat(uint id, uint idx) const
	{
		auto& nd = *_nd;

		auto& info = nd.buf_light_infos.pstag->light_infos[id];
		if (info.shadow_index == -1)
			return mat4(1.f);

		switch (info.type)
		{
		case LightDirectional:
			return nd.buf_dir_shadows.pstag->dir_shadows[info.shadow_index].mats[idx];
		case LightPoint:
			return nd.buf_pt_shadows.pstag->pt_shadows[info.shadow_index].mats[idx];
		}

		return mat4(1.f);
	}

	uint sRendererPrivate::add_mesh_transform(const mat4& mat, const mat3& nor)
	{
		auto& nd = *_nd;

		auto idx = nd.buf_mesh_transforms.n;

		auto& data = nd.buf_mesh_transforms.add_item();
		data.mat = mat;
		data.nor = nor;

		return idx;
	}

	uint sRendererPrivate::add_mesh_armature(uint bones_count, const mat4* bones)
	{
		auto& nd = *_nd;

		auto idx = nd.buf_mesh_armatures.n;
		auto& data = nd.buf_mesh_armatures.add_item_overwrite_size(sizeof(mat4) * bones_count);
		memcpy(data.bones, bones, sizeof(mat4) * bones_count);
		return idx;
	}

	void sRendererPrivate::draw_mesh(uint idx, uint mesh_id, uint skin, ShadingFlags flags)
	{
		auto& nd = *_nd;

		if (render_type != ShadingMaterial)
			flags = (ShadingFlags)(flags & ~ShadingMaterial);
		if (render_type == RenderWireframe)
			flags = flags | ShadingWireframe;

		auto& mesh = nd.mesh_reses[mesh_id];

		if (flags & ShadingShadow)
		{
			auto usage = mesh.arm ? MaterialForMeshShadowArmature : MaterialForMeshShadow;
			nd.meshes[usage][mesh.mat_ids[skin]].emplace_back(idx, mesh_id);
		}
		else
		{
			auto usage = mesh.arm ? MaterialForMeshArmature : MaterialForMesh;
			if (flags & ShadingMaterial)
				nd.meshes[usage][mesh.mat_ids[skin]].emplace_back(idx, mesh_id);
			if (flags & ShadingWireframe)
				nd.meshes[usage][MaterialWireframe].emplace_back(idx, mesh_id);
			if (flags & ShadingOutline)
				nd.meshes[usage][MaterialOutline].emplace_back(idx, mesh_id);
			if (render_type == RenderNormalData)
				nd.meshes[usage][MaterialNormalData].emplace_back(idx, mesh_id);
		}
	}

	void sRendererPrivate::draw_terrain(const vec3& coord, const vec3& extent, const uvec2& blocks, uint tess_levels, uint height_map_id, 
		uint normal_map_id, uint tangent_map_id, uint material_id, ShadingFlags flags)
	{
		auto& nd = *_nd;

		if (render_type != ShadingMaterial)
			flags = (ShadingFlags)(flags & ~ShadingMaterial);

		auto& data = nd.buf_terrain.add_item();
		data.coord = coord;
		data.extent = extent;
		data.blocks = blocks;
		data.tess_levels = tess_levels;
		data.height_map_id = height_map_id;
		data.normal_map_id = normal_map_id;
		data.tangent_map_id = tangent_map_id;
		data.material_id = material_id;

		auto dispatch_count = blocks.x * blocks.y;
		if (flags & ShadingMaterial)
			nd.terrains[MaterialCustom].emplace_back(dispatch_count, material_id);
		if (render_type == RenderWireframe || (flags & ShadingWireframe))
			nd.terrains[MaterialWireframe].emplace_back(dispatch_count, material_id);
		if (flags & ShadingOutline)
			nd.terrains[MaterialOutline].emplace_back(dispatch_count, material_id);
		if (render_type == RenderNormalData)
			nd.terrains[MaterialNormalData].emplace_back(dispatch_count, material_id);
	}

	void sRendererPrivate::draw_water(const vec3& coord, const vec2& extent,
		uint material_id, ShadingFlags flags)
	{
		auto& nd = *_nd;

		if (render_type != ShadingMaterial)
			flags = (ShadingFlags)(flags & ~ShadingMaterial);

		auto& data = nd.buf_water.add_item();
		data.coord = coord;
		data.extent = extent;
		data.material_id = material_id;

		if (flags & ShadingMaterial)
			nd.waters[MaterialCustom].emplace_back(0, material_id);
		if (render_type == RenderWireframe || (flags & ShadingWireframe))
			nd.waters[MaterialWireframe].emplace_back(0, material_id);
		if (flags & ShadingOutline)
			nd.waters[MaterialOutline].emplace_back(0, material_id);
		if (render_type == RenderNormalData)
			nd.waters[MaterialNormalData].emplace_back(0, material_id);
	}

	void sRendererPrivate::draw_particles(uint count, Particle* partcles, uint res_id)
	{
		auto& nd = *_nd;

		if (nd.particles.back().first != res_id)
			nd.particles.emplace_back(res_id, 0);

		auto pvtx = nd.buf_ptc_vtx.stag(count);
		for (auto i = 0; i < count; i++)
		{
			auto& p = partcles[i];
			pvtx[i] = { p.pos, p.xext, p.yext, p.uvs, p.col };
		}

		nd.particles.back().second += count;
	}

	void sRendererPrivate::draw_lines(uint count, Line* lines)
	{
		auto& nd = *_nd;

		memcpy(nd.buf_lines.stag(count), lines, count * sizeof(Line));
	}

	const auto shadow_map_size = uvec2(1024);

	void sRendererPrivate::render(uint tar_idx, CommandBuffer* cb)
	{
		tar_idx = min((uint)img_tars.size() - 1, tar_idx);
		if (img_tars.empty() || (!dirty && img_tars.size() == 1)) // window targets count should bigger than 1
			return;
		dirty = false;

		frame = get_frames();

		auto& ed = *_ed;
		ed.scissor = Rect(vec2(0.f), tar_sz);
		if (world->first_element && world->first_element->global_visibility)
		{
			ed.should_render = true;
			ed.max_layer = 0;
			element_render(0, world->first_element->get_component_i<cElementPrivate>(0));
		}
		else
			ed.should_render = false;

		auto& nd = *_nd;
		{ // TODO
			auto& data = nd.buf_tile_lights.item(0);
			data.dir_count = 0;
			data.pt_count = 0;
		}
		if (world->first_node && world->first_node->global_visibility && camera)
		{
			nd.should_render = true;
			Frustum frustums[MaxLod + 1];
			auto dist = camera->far;
			for (auto i = 0; i <= MaxLod; i++)
			{
				frustums[i] = camera->get_frustum(-1.f, dist);
				dist /= 2.f;
			}
			node_render(world->first_node->get_component_i<cNodePrivate>(0), frustums);
		}
		else
			nd.should_render = false;

		if (nd.should_render)
		{
			{
				camera->set_screen_size(tar_sz);
				camera->update_view();
				camera->update_proj();

				auto& data = *(nd.buf_render_data.pstag);
				data.zNear = camera->near;
				data.zFar = camera->far;
				data.viewport = tar_sz;
				data.camera_coord = camera->node->g_pos;
				data.camera_dir = -camera->node->g_rot[2];
				data.view = camera->view;
				data.view_inv = camera->view_inv;
				data.proj = camera->proj;
				data.proj_inv = camera->proj_inv;
				data.proj_view = data.proj * data.view;
				*(Frustum*)data.frustum_planes = camera->get_frustum();
				data.time = frame;
			}
			nd.buf_render_data.cpy_whole();
			nd.buf_render_data.upload(cb);

			typedef std::vector<std::pair<uint, uint>> DrawIndirs;

			auto pack_mesh_indirs = [&](MaterialUsage u, bool opaque) {
				DrawIndirs ret;
				auto beg = opaque ? (uint)MaterialCustom : TrnMatBase;
				auto end = opaque ? nd.max_opq_mat_id : nd.max_trn_mat_id;
				for (auto mat_id = beg; mat_id <= end; mat_id++)
				{
					auto& vec = nd.meshes[u][mat_id];
					if (!vec.empty())
					{
						auto indirs = nd.buf_mesh_indirs[u].stag(vec.size());
						auto fill_indirs = [&](const std::vector<std::pair<uint, uint>>& vec) {
							for (auto i = 0; i < vec.size(); i++)
							{
								auto& src = vec[i];
								auto& mr = nd.mesh_reses[src.second];
								auto& dst = indirs[i];
								dst.vertex_offset = mr.vtx_off;
								dst.first_index = mr.idx_off;
								dst.index_count = mr.idx_cnt;
								dst.first_instance = (src.first << 16) + mat_id;
								dst.instance_count = 1;
							}
						};

						if (nd.mat_reses[mat_id].sort)
						{
							auto& trans = nd.buf_mesh_transforms.pstag->transforms;
							auto cam_coord = camera->node->g_pos;
							auto cam_dir = -camera->node->g_rot[2];

							auto _vec = vec;
							std::sort(_vec.begin(), _vec.end(), [&](const auto& a, const auto& b) {
								auto p1 = vec3(trans[a.first].mat[3]);
								auto p2 = vec3(trans[b.first].mat[3]);
								p1 -= cam_coord;
								p2 -= cam_coord;
								auto d1 = dot(p1, cam_dir);
								auto d2 = dot(p2, cam_dir);
								return d1 > d2;
							});
							fill_indirs(_vec);
						}
						else
							fill_indirs(vec);
						ret.emplace_back(mat_id, (uint)vec.size());
						vec.clear();
					}
				}
				return ret;
			};

			auto bind_mesh_fwd_res = [&]() {
				cb->bind_pipeline_layout(nd.pll_mesh_fwd);
				DescriptorSet* sets[mesh::PLL_forward::Binding_Max];
				sets[mesh::PLL_forward::Binding_render_data] = nd.ds_render_data.get();
				sets[mesh::PLL_forward::Binding_material] = nd.ds_material.get();
				sets[mesh::PLL_forward::Binding_light] = nd.ds_light.get();
				sets[mesh::PLL_forward::Binding_mesh] = nd.ds_mesh.get();
				cb->bind_descriptor_sets(0, countof(sets), sets);
			};

			auto bind_mesh_def_res = [&]() {
				cb->bind_pipeline_layout(nd.pll_mesh_gbuf);
				DescriptorSet* sets[mesh::PLL_gbuffer::Binding_Max];
				sets[mesh::PLL_gbuffer::Binding_render_data] = nd.ds_render_data.get();
				sets[mesh::PLL_gbuffer::Binding_material] = nd.ds_material.get();
				sets[mesh::PLL_gbuffer::Binding_mesh] = nd.ds_mesh.get();
				cb->bind_descriptor_sets(0, countof(sets), sets);
			};

			auto draw_meshes = [&](MaterialUsage u, const std::vector<std::pair<uint, uint>>& indirs, uint off = 0) {
				auto buf = nd.buf_mesh_indirs[u].buf.get();
				for (auto& i : indirs)
				{
					cb->bind_pipeline(nd.mat_reses[i.first].get_pl(this, u));
					cb->draw_indexed_indirect(buf, off, i.second);
					off += i.second;
				}
				return off;
			};

			auto bind_terrain_fwd_res = [&]() {
				cb->bind_pipeline_layout(nd.pll_terrain_fwd);
				DescriptorSet* sets[terrain::PLL_forward::Binding_Max];
				sets[terrain::PLL_forward::Binding_render_data] = nd.ds_render_data.get();
				sets[terrain::PLL_forward::Binding_material] = nd.ds_material.get();
				sets[terrain::PLL_forward::Binding_light] = nd.ds_light.get();
				sets[terrain::PLL_forward::Binding_terrain] = nd.ds_terrain.get();
				cb->bind_descriptor_sets(0, countof(sets), sets);
			};

			auto bind_terrain_def_res = [&]() {
				cb->bind_pipeline_layout(nd.pll_terrain_gbuf);
				DescriptorSet* sets[terrain::PLL_gbuffer::Binding_Max];
				sets[terrain::PLL_gbuffer::Binding_render_data] = nd.ds_render_data.get();
				sets[terrain::PLL_gbuffer::Binding_material] = nd.ds_material.get();
				sets[terrain::PLL_gbuffer::Binding_terrain] = nd.ds_terrain.get();
				cb->bind_descriptor_sets(0, countof(sets), sets);
			};

			auto draw_terrains = [&]() {
				auto& vec = nd.terrains[MaterialCustom];
				for (auto i = 0; i < vec.size(); i++)
				{
					cb->bind_pipeline(nd.mat_reses[vec[i].second].get_pl(this, MaterialForTerrain));
					cb->draw(4, vec[i].first, 0, i << 16);
				}
				vec.clear();
			};

			auto bind_water_res = [&]() {
				cb->bind_pipeline_layout(nd.pll_water);
				DescriptorSet* sets[water::PLL_water::Binding_Max];
				sets[water::PLL_water::Binding_render_data] = nd.ds_render_data.get();
				sets[water::PLL_water::Binding_material] = nd.ds_material.get();
				sets[water::PLL_water::Binding_light] = nd.ds_light.get();
				sets[water::PLL_water::Binding_water] = nd.ds_water.get();
				cb->bind_descriptor_sets(0, countof(sets), sets);
			};

			auto draw_waters = [&]() {
				auto& vec = nd.waters[MaterialCustom];
				for (auto i = 0; i < vec.size(); i++)
				{
					cb->bind_pipeline(nd.mat_reses[vec[i].second].get_pl(this, MaterialForWater));
					cb->draw(6, 1, 0, i << 16);
				}
				vec.clear();
			};

			std::function<void(cNodePrivate*, const Frustum&)> collect_occluders;
			collect_occluders = [&](cNodePrivate* node, const Frustum& frustum) {
				auto e = node->entity;

				node->update_transform();
				if (AABB_frustum_check(frustum, node->bounds))
					node->draw(frame, true);

				if (node->octree)
				{
					std::vector<cNodePrivate*> objs;
					node->octree->get_within_frustum(frustum, objs);
					for (auto obj : objs)
						collect_occluders(obj, frustum);
				}
				else
				{
					for (auto& c : e->children)
					{
						if (!c->global_visibility)
							continue;

						auto cnode = c->get_component_i<cNodePrivate>(0);
						if (cnode)
							collect_occluders(cnode, frustum);
					}
				}
			};

			std::vector<std::vector<DrawIndirs>> dir_shadow_mesh_indirs;
			std::vector<std::vector<DrawIndirs>> dir_shadow_mesh_arm_indirs;
			std::vector<std::vector<DrawIndirs>> pt_shadow_mesh_indirs;
			std::vector<std::vector<DrawIndirs>> pt_shadow_mesh_arm_indirs;
			if (render_type == RenderShaded)
			{
				for (auto& s : nd.dir_shadows)
				{
					auto rot = s.second;
					rot[2] *= -1.f;
					auto inv = inverse(rot);

					auto& data = nd.buf_dir_shadows.add_item();
					data.far = camera->far;

					auto& mesh_indirs_vec = dir_shadow_mesh_indirs.emplace_back();
					auto& mesh_arm_indirs_vec = dir_shadow_mesh_arm_indirs.emplace_back();
					for (auto i = 0; i < 4; i++)
					{
						if (i < nd.dir_shadow_levels)
						{
							auto n = i / (float)nd.dir_shadow_levels;
							n = n * n * nd.dir_shadow_dist;
							auto f = (i + 1) / (float)nd.dir_shadow_levels;
							f = f * f * nd.dir_shadow_dist;

							AABB b; b.reset();
							vec3 ps[8];
							camera->get_points(ps, n, f);
							for (auto k = 0; k < 8; k++)
								b.expand(inv * ps[k]);
							auto hf_xlen = (b.b.x - b.a.x) * 0.5f;
							auto hf_ylen = (b.b.y - b.a.y) * 0.5f;
							auto c = rot * b.center();

							auto proj = orthoRH(-hf_xlen, +hf_xlen, -hf_ylen, +hf_ylen, 0.f, data.far);
							proj[1][1] *= -1.f;
							auto view = lookAt(c + rot[2] * (data.far - (b.b.z - b.a.z)), c, rot[1]);

							auto mat = proj * view;
							data.mats[i] = mat;
							data.splits[i] = f;

							collect_occluders(world->first_node->get_component_i<cNodePrivate>(0), Frustum(inverse(mat)));
							mesh_indirs_vec.push_back(pack_mesh_indirs(MaterialForMeshShadow, true));
							mesh_arm_indirs_vec.push_back(pack_mesh_indirs(MaterialForMeshShadowArmature, true));
						}
						else
							data.splits[i] = 0.f;
					}
				}

				for (auto& s : nd.pt_shadows)
				{
					auto near = 0.1f;

					auto proj = perspective(radians(90.f), near, 1.f, nd.pt_shadow_dist);
					proj[1][1] *= -1.f;

					auto& data = nd.buf_pt_shadows.add_item();

					auto& mesh_indirs_vec = pt_shadow_mesh_indirs.emplace_back();
					auto& mesh_arm_indirs_vec = pt_shadow_mesh_arm_indirs.emplace_back();
					for (auto i = 0; i < 6; i++)
					{
						auto& matrix = data.mats[i];
						switch (i)
						{
						case 0:
							matrix[0][0] = -1.f;
							matrix = matrix * proj * lookAt(s.second, s.second + vec3(1.f, 0.f, 0.f), vec3(0.f, 1.f, 0.f));
							break;
						case 1:
							matrix[0][0] = -1.f;
							matrix = matrix * proj * lookAt(s.second, s.second + vec3(-1.f, 0.f, 0.f), vec3(0.f, 1.f, 0.f));
							break;
						case 2:
							matrix[1][1] = -1.f;
							matrix = matrix * proj * lookAt(s.second, s.second + vec3(0.f, 1.f, 0.f), vec3(1.f, 0.f, 0.f));
							break;
						case 3:
							matrix[1][1] = -1.f;
							matrix = matrix * proj * lookAt(s.second, s.second + vec3(0.f, -1.f, 0.f), vec3(0.f, 0.f, -1.f));
							break;
						case 4:
							matrix[0][0] = -1.f;
							matrix = matrix * proj * lookAt(s.second, s.second + vec3(0.f, 0.f, 1.f), vec3(0.f, 1.f, 0.f));
							break;
						case 5:
							matrix[0][0] = -1.f;
							matrix = matrix * proj * lookAt(s.second, s.second + vec3(0.f, 0.f, -1.f), vec3(0.f, 1.f, 0.f));
							break;
						}

						collect_occluders(world->first_node->get_component_i<cNodePrivate>(0), Frustum(inverse(matrix)));
						mesh_indirs_vec.push_back(pack_mesh_indirs(MaterialForMeshShadow, true));
						mesh_arm_indirs_vec.push_back(pack_mesh_indirs(MaterialForMeshShadowArmature, true));

					}
					data.near = near;
					data.far = nd.pt_shadow_dist;
				}
			}

			nd.buf_mesh_transforms.upload(cb);
			nd.buf_mesh_armatures.upload(cb);
			nd.buf_terrain.upload(cb);
			nd.buf_water.upload(cb);
			nd.buf_ptc_vtx.upload(cb);
			nd.buf_light_infos.upload(cb);
			nd.buf_tile_lights.upload(cb);
			nd.buf_dir_shadows.upload(cb);
			nd.buf_pt_shadows.upload(cb);

			if (render_type == RenderShaded)
			{
				nd.buf_mesh_indirs[MaterialForMeshShadow].upload(cb);
				nd.buf_mesh_indirs[MaterialForMeshShadowArmature].upload(cb);

				cb->set_viewport(Rect(0.f, 0.f, shadow_map_size.x, shadow_map_size.y));
				cb->set_scissor(Rect(0.f, 0.f, shadow_map_size.x, shadow_map_size.y));

				auto dir_mesh_indirs_off = 0;
				auto dir_mesh_arm_indirs_off = 0;
				for (auto i = 0; i < nd.dir_shadows.size(); i++)
				{
					auto& mesh_indirs_vec = dir_shadow_mesh_indirs[i];
					auto& mesh_arm_indirs_vec = dir_shadow_mesh_arm_indirs[i];
					for (auto lv = 0; lv < nd.dir_shadow_levels; lv++)
					{
						auto cv = vec4(1.f, 0.f, 0.f, 0.f);
						cb->begin_renderpass(nullptr, nd.img_dir_shadow_maps[i]->get_shader_write_dst(0, lv, AttachmentLoadClear), &cv);
						bind_mesh_fwd_res();
						cb->push_constant_t(mesh::PLL_forward::PushConstant{ .i = ivec4(0, i, lv, 0) });
						cb->bind_vertex_buffer(nd.buf_mesh_vtx.buf.get(), 0);
						cb->bind_index_buffer(nd.buf_mesh_idx.buf.get(), IndiceTypeUint);
						dir_mesh_indirs_off = draw_meshes(MaterialForMeshShadow, mesh_indirs_vec[lv], dir_mesh_indirs_off);
						cb->bind_vertex_buffer(nd.buf_arm_mesh_vtx.buf.get(), 0);
						cb->bind_index_buffer(nd.buf_arm_mesh_idx.buf.get(), IndiceTypeUint);
						dir_mesh_arm_indirs_off = draw_meshes(MaterialForMeshShadowArmature, mesh_arm_indirs_vec[lv], dir_mesh_arm_indirs_off);
						cb->end_renderpass();
					}

					cb->image_barrier(nd.img_dir_shadow_maps[i].get(), { 0U, 1U, 0U, nd.dir_shadow_levels }, ImageLayoutAttachment, ImageLayoutShaderReadOnly);
				}

				cb->set_viewport(Rect(0.f, 0.f, shadow_map_size.x * 0.5f, shadow_map_size.y * 0.5f));
				cb->set_scissor(Rect(0.f, 0.f, shadow_map_size.x * 0.5f, shadow_map_size.y * 0.5f));

				auto pt_mesh_indirs_off = 0;
				auto pt_mesh_arm_indirs_off = 0;
				for (auto i = 0; i < nd.pt_shadows.size(); i++)
				{
					auto& mesh_indirs_vec = pt_shadow_mesh_indirs[i];
					auto& mesh_arm_indirs_vec = pt_shadow_mesh_arm_indirs[i];
					for (auto ly = 0; ly < 6; ly++)
					{
						auto cv = vec4(1.f, 0.f, 0.f, 0.f);
						cb->begin_renderpass(nullptr, nd.img_pt_shadow_maps[i]->get_shader_write_dst(0, ly, AttachmentLoadClear), &cv);
						bind_mesh_fwd_res();
						cb->push_constant_t(mesh::PLL_forward::PushConstant{ .i = ivec4(1, i, ly, 0) });
						cb->bind_vertex_buffer(nd.buf_mesh_vtx.buf.get(), 0);
						cb->bind_index_buffer(nd.buf_mesh_idx.buf.get(), IndiceTypeUint);
						pt_mesh_indirs_off = draw_meshes(MaterialForMeshShadow, mesh_indirs_vec[ly], pt_mesh_indirs_off);
						cb->bind_vertex_buffer(nd.buf_arm_mesh_vtx.buf.get(), 0);
						cb->bind_index_buffer(nd.buf_arm_mesh_idx.buf.get(), IndiceTypeUint);
						pt_mesh_arm_indirs_off = draw_meshes(MaterialForMeshShadowArmature, mesh_arm_indirs_vec[ly], pt_mesh_arm_indirs_off);
						cb->end_renderpass();
					}

					cb->image_barrier(nd.img_pt_shadow_maps[i].get(), { 0U, 1U, 0U, 6U }, ImageLayoutAttachment, ImageLayoutShaderReadOnly);
				}
			}

			nd.dir_shadows.clear();
			nd.pt_shadows.clear();

			auto fb_tar = fb_tars[tar_idx].get();
			auto vp = Rect(vec2(0.f), tar_sz);
			cb->set_viewport(vp);
			cb->set_scissor(vp);

			if (render_type == RenderShaded)
			{
				// stag here cause can not update buffer while in render pass
				auto opq_mesh_indirs = pack_mesh_indirs(MaterialForMesh, true);
				auto opq_mesh_arm_indirs = pack_mesh_indirs(MaterialForMeshArmature, true);
				auto trn_mesh_indirs = pack_mesh_indirs(MaterialForMesh, false);
				auto trn_mesh_arm_indirs = pack_mesh_indirs(MaterialForMeshArmature, false);
				nd.buf_mesh_indirs[MaterialForMesh].upload(cb);
				nd.buf_mesh_indirs[MaterialForMeshArmature].upload(cb);
				auto mesh_indirs_off = 0;
				auto mesh_arm_indirs_off = 0;

				vec4 cvs[] = {
					vec4(0.f, 0.f, 0.f, 0.f),
					vec4(0.f, 0.f, 0.f, 0.f),
					vec4(1.f, 0.f, 0.f, 0.f),
					vec4(0.f, 0.f, 0.f, 0.f)
				};
				cb->begin_renderpass(nullptr, nd.fb_gbuf.get(), cvs);
				bind_mesh_def_res();
				cb->bind_vertex_buffer(nd.buf_mesh_vtx.buf.get(), 0);
				cb->bind_index_buffer(nd.buf_mesh_idx.buf.get(), IndiceTypeUint);
				mesh_indirs_off = draw_meshes(MaterialForMesh, opq_mesh_indirs, mesh_indirs_off);
				cb->bind_vertex_buffer(nd.buf_arm_mesh_vtx.buf.get(), 0);
				cb->bind_index_buffer(nd.buf_arm_mesh_idx.buf.get(), IndiceTypeUint);
				mesh_arm_indirs_off = draw_meshes(MaterialForMeshArmature, opq_mesh_arm_indirs, mesh_arm_indirs_off);
				bind_terrain_def_res();
				draw_terrains();
				cb->end_renderpass();

				cb->image_barrier(nd.img_col_met.get(), {}, ImageLayoutAttachment, ImageLayoutShaderReadOnly);
				cb->image_barrier(nd.img_nor_rou.get(), {}, ImageLayoutAttachment, ImageLayoutShaderReadOnly);
				cb->image_barrier(nd.img_dep.get(), {}, ImageLayoutAttachment, ImageLayoutShaderReadOnly);

				cb->set_viewport(vec4(vp) * 0.5f);
				cb->begin_renderpass(nullptr, nd.img_ao_back->get_shader_write_dst());
				cb->bind_pipeline(nd.pl_ssao);
				{
					DescriptorSet* sets[PLL_ssao::Binding_Max];
					sets[PLL_ssao::Binding_ssao] = nd.ds_ssao.get();
					sets[PLL_ssao::Binding_render_data] = nd.ds_render_data.get();
					cb->bind_descriptor_sets(0, countof(sets), sets);
				}
				cb->push_constant_t(PLL_ssao::PushConstant{ nd.ssao_radius, nd.ssao_bias });
				cb->draw(3, 1, 0, 0);
				cb->end_renderpass();

				cb->image_barrier(nd.img_ao_back.get(), {}, ImageLayoutAttachment, ImageLayoutShaderReadOnly);
				cb->begin_renderpass(nullptr, nd.img_ao->get_shader_write_dst());
				cb->bind_pipeline(nd.pl_ssao_blur);
				cb->bind_descriptor_set(0, nd.img_ao_back->get_shader_read_src());
				cb->push_constant_t(PLL_post::PushConstant{ .pxsz = { 1.f / vec2(nd.img_ao->get_size()) } });
				cb->draw(3, 1, 0, 0);
				cb->end_renderpass();
				cb->image_barrier(nd.img_ao.get(), {}, ImageLayoutAttachment, ImageLayoutShaderReadOnly);

				cb->set_viewport(vp);
				cb->begin_renderpass(nullptr, img_dst->get_shader_write_dst());
				cb->bind_pipeline(nd.pl_def);
				{
					DescriptorSet* sets[PLL_deferred::Binding_Max];
					sets[PLL_deferred::Binding_deferred] = nd.ds_def.get();
					sets[PLL_deferred::Binding_render_data] = nd.ds_render_data.get();
					sets[PLL_deferred::Binding_light] = nd.ds_light.get();
					cb->bind_descriptor_sets(0, countof(sets), sets);
				}
				cb->draw(3, 1, 0, 0);
				cb->end_renderpass();
				cb->image_barrier(img_dst.get(), {}, ImageLayoutAttachment, ImageLayoutShaderReadOnly);

				cb->begin_renderpass(nullptr, nd.img_dep_back->get_shader_write_dst());
				cb->bind_pipeline(nd.pl_blit_d16);
				cb->bind_descriptor_set(0, nd.img_dep->get_shader_read_src(0, 0, sp_nearest));
				cb->draw(3, 1, 0, 0);
				cb->end_renderpass();
				cb->image_barrier(nd.img_dep_back.get(), {}, ImageLayoutAttachment, ImageLayoutShaderReadOnly);

				cb->begin_renderpass(nullptr, nd.img_col_ms->get_shader_write_dst());
				cb->bind_pipeline(nd.pl_blit_rgba16ms4);
				cb->bind_descriptor_set(0, img_dst->get_shader_read_src(0, 0, sp_nearest));
				cb->draw(3, 1, 0, 0);
				cb->end_renderpass();

				cb->begin_renderpass(nullptr, nd.img_dep_ms->get_shader_write_dst());
				cb->bind_pipeline(nd.pl_blit_d16ms4);
				cb->bind_descriptor_set(0, nd.img_dep->get_shader_read_src(0, 0, sp_nearest));
				cb->draw(3, 1, 0, 0);
				cb->end_renderpass();

				cb->image_barrier(img_dst.get(), {}, ImageLayoutShaderReadOnly, ImageLayoutAttachment);
				cb->begin_renderpass(nullptr, nd.fb_fwd_ms4.get());
				bind_mesh_fwd_res();
				cb->bind_vertex_buffer(nd.buf_mesh_vtx.buf.get(), 0);
				cb->bind_index_buffer(nd.buf_mesh_idx.buf.get(), IndiceTypeUint);
				mesh_indirs_off = draw_meshes(MaterialForMesh, trn_mesh_indirs, mesh_indirs_off);
				cb->bind_vertex_buffer(nd.buf_arm_mesh_vtx.buf.get(), 0);
				cb->bind_index_buffer(nd.buf_arm_mesh_idx.buf.get(), IndiceTypeUint);
				mesh_arm_indirs_off = draw_meshes(MaterialForMeshArmature, trn_mesh_arm_indirs, mesh_arm_indirs_off);
				if (!nd.waters[MaterialCustom].empty())
				{
					bind_water_res();
					draw_waters();
				}
				if (nd.particles.size() > 1)
				{
					cb->bind_vertex_buffer(nd.buf_ptc_vtx.buf.get(), 0);
					cb->bind_pipeline(nd.pl_ptc);
					{
						DescriptorSet* sets[PLL_particle::Binding_Max];
						sets[PLL_particle::Binding_render_data] = nd.ds_render_data.get();
						sets[PLL_particle::Binding_material] = nd.ds_material.get();
						cb->bind_descriptor_sets(0, countof(sets), sets);
					}
					auto cnt = 0;
					for (auto& vec : nd.particles)
					{
						if (vec.second == 0)
							continue;
						cb->draw(vec.second, 1, cnt, vec.first);
						cnt += vec.second;
					}

					nd.particles.clear();
					nd.particles.emplace_back(0xffff, 0);
				}
				cb->end_renderpass();

				cb->image_barrier(img_dst.get(), {}, ImageLayoutAttachment, ImageLayoutGeneral);
				cb->bind_pipeline_layout(nd.pll_lum, PipelineCompute);
				cb->bind_descriptor_set(0, nd.ds_lum.get());
				cb->push_constant_t(PLL_luminance::PushConstant{ nd.min_log_lum, nd.max_log_lum - nd.min_log_lum, 1.1f, float(tar_sz.x * tar_sz.y) });
				cb->bind_pipeline(nd.pl_lum_htg);
				cb->dispatch(uvec3(ceil(tar_sz.x / 16), ceil(tar_sz.y / 16), 1));
				cb->buffer_barrier(nd.buf_lum_htg.buf.get(), AccessShaderRead | AccessShaderWrite, AccessShaderRead | AccessShaderWrite,
					PipelineStageCompShader, PipelineStageCompShader);
				cb->bind_pipeline(nd.pl_lum_avg);
				cb->dispatch(uvec3(256, 1, 1));
				cb->buffer_barrier(nd.buf_lum_avg.buf.get(), AccessShaderRead | AccessShaderWrite, AccessShaderRead,
					PipelineStageCompShader, PipelineStageAllGraphics);

				cb->image_barrier(img_dst.get(), {}, ImageLayoutGeneral, ImageLayoutShaderReadOnly);
				cb->begin_renderpass(nullptr, nd.img_dst_back->get_shader_write_dst());
				cb->bind_pipeline(nd.pl_bright);
				cb->bind_descriptor_set(0, img_dst->get_shader_read_src(0, 0, sp_nearest));
				cb->push_constant_t(PLL_post::PushConstant{ .f = vec4(nd.white_point, 0.f, 0.f, 0.f) });
				cb->draw(3, 1, 0, 0);
				cb->end_renderpass();

				auto lvs = nd.img_dst_back->get_levels();
				for (auto i = 0; i < lvs - 1; i++)
				{
					cb->image_barrier(nd.img_dst_back.get(), { (uint)i }, ImageLayoutAttachment, ImageLayoutShaderReadOnly);
					cb->set_viewport(Rect(vec2(0.f), nd.img_dst_back->get_size(i + 1)));
					cb->begin_renderpass(nullptr, nd.img_dst_back->get_shader_write_dst(i + 1));
					cb->bind_pipeline(nd.pl_downsample);
					cb->bind_descriptor_set(0, nd.img_dst_back->get_shader_read_src(i, 0, sp_linear));
					cb->push_constant_t(1.f / vec2(nd.img_dst_back->get_size(i)));
					cb->draw(3, 1, 0, 0);
					cb->end_renderpass();
				}
				for (auto i = lvs - 1; i > 1; i--)
				{
					cb->image_barrier(nd.img_dst_back.get(), { (uint)i }, ImageLayoutAttachment, ImageLayoutShaderReadOnly);
					cb->set_viewport(Rect(vec2(0.f), nd.img_dst_back->get_size(i - 1)));
					cb->image_barrier(nd.img_dst_back.get(), { (uint)i - 1 }, ImageLayoutShaderReadOnly, ImageLayoutAttachment);
					cb->begin_renderpass(nullptr, nd.img_dst_back->get_shader_write_dst(i - 1, 0, AttachmentLoadLoad));
					cb->bind_pipeline(nd.pl_upsample);
					cb->bind_descriptor_set(0, nd.img_dst_back->get_shader_read_src(i, 0, sp_linear));
					cb->push_constant_t(1.f / vec2(nd.img_dst_back->get_size(i)));
					cb->draw(3, 1, 0, 0);
					cb->end_renderpass();
				}
				cb->image_barrier(nd.img_dst_back.get(), { 1U }, ImageLayoutAttachment, ImageLayoutShaderReadOnly);
				cb->set_viewport(vp);
				cb->image_barrier(img_dst.get(), {}, ImageLayoutShaderReadOnly, ImageLayoutAttachment);
				cb->begin_renderpass(nullptr, img_dst->get_shader_write_dst(0, 0, AttachmentLoadLoad));
				cb->bind_pipeline(nd.pl_upsample);
				cb->bind_descriptor_set(0, nd.img_dst_back->get_shader_read_src(1, 0, sp_linear));
				cb->push_constant_t(1.f / vec2(nd.img_dst_back->get_size(1)));
				cb->draw(3, 1, 0, 0);
				cb->end_renderpass();

				cb->image_barrier(img_dst.get(), {}, ImageLayoutAttachment, ImageLayoutShaderReadOnly);
				cb->begin_renderpass(nullptr, fb_tar);
				cb->bind_pipeline(nd.pl_tone);
				cb->bind_descriptor_set(0, nd.ds_tone.get());
				cb->push_constant_t(PLL_tone::PushConstant{ nd.white_point, 1.f / nd.gamma });
				cb->draw(3, 1, 0, 0);
				cb->end_renderpass();
			}
			else
			{
				vec4 cvs[] = {
					vec4(0.f, 0.f, 0.f, 0.f),
					vec4(1.f, 0.f, 0.f, 0.f)
				};
				cb->begin_renderpass(nullptr, nd.fb_tars_dep[tar_idx].get(), cvs);

				switch (render_type)
				{
				case RenderNormalData:
				{
					auto& meshes = nd.meshes[MaterialForMesh][MaterialNormalData];
					auto& arm_meshes = nd.meshes[MaterialForMeshArmature][MaterialNormalData];
					auto& terrains = nd.terrains[MaterialNormalData];
					if (!meshes.empty() || !arm_meshes.empty() || !terrains.empty())
					{
						if (!meshes.empty())
						{
							cb->bind_vertex_buffer(nd.buf_mesh_vtx.buf.get(), 0);
							cb->bind_index_buffer(nd.buf_mesh_idx.buf.get(), IndiceTypeUint);
							bind_mesh_fwd_res();
							cb->bind_pipeline(nd.mat_reses[MaterialNormalData].get_pl(this, MaterialForMesh));
							for (auto& m : meshes)
							{
								auto& mr = nd.mesh_reses[m.second];
								cb->draw_indexed(mr.idx_cnt, mr.idx_off, mr.vtx_off, 1, (m.first << 16) + mr.mat_ids[0]);
							}
							meshes.clear();
						}
						if (!arm_meshes.empty())
						{
							cb->bind_vertex_buffer(nd.buf_arm_mesh_vtx.buf.get(), 0);
							cb->bind_index_buffer(nd.buf_arm_mesh_idx.buf.get(), IndiceTypeUint);
							bind_mesh_fwd_res();
							cb->push_constant_t(vec4(0.f, 1.f, 0.f, 1.f));
							cb->bind_pipeline(nd.mat_reses[MaterialNormalData].get_pl(this, MaterialForMeshArmature));
							for (auto& m : arm_meshes)
							{
								auto& mr = nd.mesh_reses[m.second];
								cb->draw_indexed(mr.idx_cnt, mr.idx_off, mr.vtx_off, 1, (m.first << 16) + mr.mat_ids[0]);
							}
							arm_meshes.clear();
						}
						if (!terrains.empty())
						{
							bind_terrain_fwd_res();
							cb->push_constant_t(vec4(0.f, 1.f, 0.f, 1.f));
							for (auto i = 0; i < terrains.size(); i++)
							{
								cb->bind_pipeline(nd.mat_reses[MaterialNormalData].get_pl(this, MaterialForTerrain));
								cb->draw(4, terrains[i].first, 0, i << 16);
							}
							terrains.clear();
						}
					}
				}
					break;
				}

				cb->end_renderpass();
			}

			auto& wireframe_meshes = nd.meshes[MaterialForMesh][MaterialWireframe];
			auto& wireframe_arm_meshes = nd.meshes[MaterialForMeshArmature][MaterialWireframe];
			auto& wireframe_terrains = nd.terrains[MaterialWireframe];
			if (!wireframe_meshes.empty() || !wireframe_arm_meshes.empty() || !wireframe_terrains.empty())
			{
				cb->begin_renderpass(rp_bgra8l, fb_tar);
				if (!wireframe_meshes.empty())
				{
					cb->bind_vertex_buffer(nd.buf_mesh_vtx.buf.get(), 0);
					cb->bind_index_buffer(nd.buf_mesh_idx.buf.get(), IndiceTypeUint);
					bind_mesh_fwd_res();
					cb->push_constant_t(vec4(0.f, 1.f, 0.f, 1.f));
					cb->bind_pipeline(nd.mat_reses[MaterialWireframe].get_pl(this, MaterialForMesh));
					for (auto& m : wireframe_meshes)
					{
						auto& mr = nd.mesh_reses[m.second];
						cb->draw_indexed(mr.idx_cnt, mr.idx_off, mr.vtx_off, 1, (m.first << 16) + mr.mat_ids[0]);
					}
					wireframe_meshes.clear();
				}
				if (!wireframe_arm_meshes.empty())
				{
					cb->bind_vertex_buffer(nd.buf_arm_mesh_vtx.buf.get(), 0);
					cb->bind_index_buffer(nd.buf_arm_mesh_idx.buf.get(), IndiceTypeUint);
					bind_mesh_fwd_res();
					cb->push_constant_t(vec4(0.f, 1.f, 0.f, 1.f));
					cb->bind_pipeline(nd.mat_reses[MaterialWireframe].get_pl(this, MaterialForMeshArmature));
					for (auto& m : wireframe_arm_meshes)
					{
						auto& mr = nd.mesh_reses[m.second];
						cb->draw_indexed(mr.idx_cnt, mr.idx_off, mr.vtx_off, 1, (m.first << 16) + mr.mat_ids[0]);
					}
					wireframe_arm_meshes.clear();
				}
				if (!wireframe_terrains.empty())
				{
					bind_terrain_fwd_res();
					cb->push_constant_t(vec4(0.f, 1.f, 0.f, 1.f));
					for (auto i = 0; i < wireframe_terrains.size(); i++)
					{
						cb->bind_pipeline(nd.mat_reses[MaterialWireframe].get_pl(this, MaterialForTerrain));
						cb->draw(4, wireframe_terrains[i].first, 0, i << 16);
					}
					wireframe_terrains.clear();
				}
				cb->end_renderpass();
			}

			auto& outline_meshes = nd.meshes[MaterialForMesh][MaterialOutline];
			auto& outline_arm_meshes = nd.meshes[MaterialForMeshArmature][MaterialOutline];
			auto& outline_terrains = nd.terrains[MaterialOutline];
			if (!outline_meshes.empty() || !outline_arm_meshes.empty() || !outline_terrains.empty())
			{
				auto cv = vec4(0.f);
				cb->begin_renderpass(nullptr, nd.img_dst_back->get_shader_write_dst(0, 0, AttachmentLoadClear), &cv);
				if (!outline_meshes.empty())
				{
					cb->bind_vertex_buffer(nd.buf_mesh_vtx.buf.get(), 0);
					cb->bind_index_buffer(nd.buf_mesh_idx.buf.get(), IndiceTypeUint);
					bind_mesh_fwd_res();
					cb->push_constant_t(vec4(1.f, 1.f, 0.f, 1.f));
					cb->bind_pipeline(nd.mat_reses[MaterialOutline].get_pl(this, MaterialForMesh));
					for (auto& m : outline_meshes)
					{
						auto& mr = nd.mesh_reses[m.second];
						cb->draw_indexed(mr.idx_cnt, mr.idx_off, mr.vtx_off, 1, (m.first << 16) + mr.mat_ids[0]);
					}
				}
				if (!outline_arm_meshes.empty())
				{
					cb->bind_vertex_buffer(nd.buf_arm_mesh_vtx.buf.get(), 0);
					cb->bind_index_buffer(nd.buf_arm_mesh_idx.buf.get(), IndiceTypeUint);
					bind_mesh_fwd_res();
					cb->push_constant_t(vec4(1.f, 1.f, 0.f, 1.f));
					cb->bind_pipeline(nd.mat_reses[MaterialOutline].get_pl(this, MaterialForMeshArmature));
					for (auto& m : outline_arm_meshes)
					{
						auto& mr = nd.mesh_reses[m.second];
						cb->draw_indexed(mr.idx_cnt, mr.idx_off, mr.vtx_off, 1, (m.first << 16) + mr.mat_ids[0]);
					}
				}
				if (!outline_terrains.empty())
				{
					bind_terrain_fwd_res();
					cb->push_constant_t(vec4(1.f, 1.f, 0.f, 1.f));
					for (auto i = 0; i < outline_terrains.size(); i++)
					{
						cb->bind_pipeline(nd.mat_reses[MaterialOutline].get_pl(this, MaterialForTerrain));
						cb->draw(4, outline_terrains[i].first, 0, i << 16);
					}
				}
				cb->end_renderpass();

				auto lvs = min(nd.img_dst_back->get_levels(), 3U);
				for (auto i = 0U; i < lvs - 1; i++)
				{
					cb->image_barrier(nd.img_dst_back.get(), { i }, ImageLayoutAttachment, ImageLayoutShaderReadOnly);
					cb->set_viewport(Rect(vec2(0.f), nd.img_dst_back->get_size(i + 1)));
					cb->begin_renderpass(nullptr, nd.img_dst_back->get_shader_write_dst(i + 1, 0));
					cb->bind_pipeline(nd.pl_downsample);
					cb->bind_descriptor_set(0, nd.img_dst_back->get_shader_read_src(i, 0, sp_linear));
					cb->push_constant_t(1.f / vec2(nd.img_dst_back->get_size(i)));
					cb->draw(3, 1, 0, 0);
					cb->end_renderpass();	
				}
				for (auto i = lvs - 1; i > 0; i--)
				{
					cb->image_barrier(nd.img_dst_back.get(), { i }, ImageLayoutAttachment, ImageLayoutShaderReadOnly);
					cb->set_viewport(Rect(vec2(0.f), nd.img_dst_back->get_size(i - 1)));
					cb->begin_renderpass(nullptr, nd.img_dst_back->get_shader_write_dst(i - 1, 0));
					cb->bind_pipeline(nd.pl_upsample);
					cb->bind_descriptor_set(0, nd.img_dst_back->get_shader_read_src(i, 0, sp_linear));
					cb->push_constant_t(1.f / vec2(nd.img_dst_back->get_size(i)));
					cb->draw(3, 1, 0, 0);
					cb->end_renderpass();
				}

				cb->image_barrier(nd.img_dst_back.get(), {}, ImageLayoutAttachment, ImageLayoutShaderReadOnly);
				cb->set_viewport(vp);
				cb->begin_renderpass(nullptr, nd.img_dst_back->get_shader_write_dst());
				if (!outline_meshes.empty())
				{
					cb->bind_vertex_buffer(nd.buf_mesh_vtx.buf.get(), 0);
					cb->bind_index_buffer(nd.buf_mesh_idx.buf.get(), IndiceTypeUint);
					bind_mesh_fwd_res();
					cb->push_constant_t(vec4(0.f, 0.f, 0.f, 1.f));
					cb->bind_pipeline(nd.mat_reses[MaterialOutline].get_pl(this, MaterialForMesh));
					for (auto& m : outline_meshes)
					{
						auto& mr = nd.mesh_reses[m.second];
						cb->draw_indexed(mr.idx_cnt, mr.idx_off, mr.vtx_off, 1, (m.first << 16) + mr.mat_ids[0]);
					}
					outline_meshes.clear();
				}
				if (!outline_arm_meshes.empty())
				{
					cb->bind_vertex_buffer(nd.buf_arm_mesh_vtx.buf.get(), 0);
					cb->bind_index_buffer(nd.buf_arm_mesh_idx.buf.get(), IndiceTypeUint);
					bind_mesh_fwd_res();
					cb->push_constant_t(vec4(0.f, 0.f, 0.f, 1.f));
					cb->bind_pipeline(nd.mat_reses[MaterialOutline].get_pl(this, MaterialForMeshArmature));
					for (auto& m : outline_arm_meshes)
					{
						auto& mr = nd.mesh_reses[m.second];
						cb->draw_indexed(mr.idx_cnt, mr.idx_off, mr.vtx_off, 1, (m.first << 16) + mr.mat_ids[0]);
					}
					outline_arm_meshes.clear();
				}
				if (!outline_terrains.empty())
				{
					bind_terrain_fwd_res();
					cb->push_constant_t(vec4(0.f, 0.f, 0.f, 1.f));
					for (auto i = 0; i < outline_terrains.size(); i++)
					{
						cb->bind_pipeline(nd.mat_reses[MaterialOutline].get_pl(this, MaterialForTerrain));
						cb->draw(4, outline_terrains[i].first, 0, i << 16);
					}
					outline_terrains.clear();
				}
				cb->end_renderpass();

				cb->image_barrier(nd.img_dst_back.get(), {}, ImageLayoutAttachment, ImageLayoutShaderReadOnly);
				cb->begin_renderpass(rp_bgra8l, fb_tar);
				cb->bind_pipeline(nd.pl_add_bgra8);
				cb->bind_descriptor_set(0, nd.img_dst_back->get_shader_read_src(0, 0, sp_nearest));
				cb->draw(3, 1, 0, 0);
				cb->end_renderpass();
			}

			if (nd.buf_lines.stag_num > 0)
			{
				auto count = nd.buf_lines.stag_num;
				nd.buf_lines.upload(cb);

				cb->begin_renderpass(rp_bgra8l, fb_tar);
				cb->bind_vertex_buffer(nd.buf_lines.buf.get(), 0);
				cb->bind_pipeline(nd.pl_line);
				auto& data = *(nd.buf_render_data.pstag);
				cb->push_constant_t(data.proj_view);
				cb->draw(count * 2, 1, 0, 0);
				cb->end_renderpass();
			}
		}

		if (ed.should_render)
		{
			auto scissor = Rect(vec2(0.f), tar_sz);
			cb->set_viewport(scissor);
			cb->set_scissor(scissor);

			auto pvtx = ed.buf_vtx.pstag;
			auto pidx = ed.buf_idx.pstag;
			ed.buf_vtx.upload(cb);
			ed.buf_idx.upload(cb);

			if (nd.should_render)
				cb->begin_renderpass(rp_bgra8l, fb_tars[tar_idx].get());
			else
				cb->begin_renderpass(rp_bgra8c, fb_tars[tar_idx].get(), &clear_color);

			cb->bind_pipeline(ed.pl_element);
			cb->bind_vertex_buffer(ed.buf_vtx.buf.get(), 0);
			cb->bind_index_buffer(ed.buf_idx.buf.get(), IndiceTypeUint);
			cb->bind_descriptor_set(element::PLL_element::Binding_element, ed.ds_element.get());
			cb->push_constant_t(element::PLL_element::PushConstant{ 2.f / vec2(tar_sz) });
			auto vtx_off = 0;
			auto idx_off = 0;
			auto vtx_cnt = 0;
			auto idx_cnt = 0;
			auto res = -1;

			auto emit_draw = [&]() {
				if (vtx_cnt > 0)
				{
					cb->draw_indexed(idx_cnt, idx_off, vtx_off, 1, res);
					vtx_off += vtx_cnt;
					idx_off += idx_cnt;
					vtx_cnt = 0;
					idx_cnt = 0;
				}
			};

			for (auto i = 0; i < ed.max_layer; i++)
			{
				for (auto& info : ed.layers[i])
				{
					if (info.vertices.empty())
					{
						emit_draw();
						if (!(scissor == info.scissor))
						{
							scissor = info.scissor;
							cb->set_scissor(scissor);
						}
					}
					else
					{
						if (res != info.res)
						{
							emit_draw();
							res = info.res;
						}

						memcpy(pvtx + vtx_off + vtx_cnt, info.vertices.data(), sizeof(ElementVertex) * info.vertices.size());
						for (auto i = 0; i < info.indices.size(); i++)
							pidx[idx_off + idx_cnt + i] = vtx_cnt + info.indices[i];
						vtx_cnt += info.vertices.size();
						idx_cnt += info.indices.size();
					}
				}
				ed.layers[i].clear();
			}

			emit_draw();

			cb->end_renderpass();
		}

		nd.should_render = false;
		ed.should_render = false;
	}

	void sRendererPrivate::on_added()
	{
		sp_nearest = Sampler::get(nullptr, FilterNearest, FilterNearest, false, AddressClampToEdge);
		sp_linear = Sampler::get(nullptr, FilterLinear, FilterLinear, false, AddressClampToEdge);

		InstanceCB cb(nullptr);

		rp_rgba8 = Renderpass::get(nullptr, L"rgba8.rp");
		rp_rgba8c = Renderpass::get(nullptr, L"rgba8c.rp");
		rp_bgra8 = Renderpass::get(nullptr, L"bgra8.rp");
		rp_bgra8l = Renderpass::get(nullptr, L"bgra8l.rp");
		rp_bgra8c = Renderpass::get(nullptr, L"bgra8c.rp");

		img_white.reset(Image::create(nullptr, Format_R8G8B8A8_UNORM, uvec2(1), 1, 1,
			SampleCount_1, ImageUsageTransferDst | ImageUsageSampled));
		img_white->clear(ImageLayoutUndefined, ImageLayoutShaderReadOnly, cvec4(255));
		img_black.reset(Image::create(nullptr, Format_R8G8B8A8_UNORM, uvec2(1), 1, 1,
			SampleCount_1, ImageUsageTransferDst | ImageUsageSampled));
		img_black->clear(ImageLayoutUndefined, ImageLayoutShaderReadOnly, cvec4(0, 0, 0, 255));
		img_black_cube.reset(Image::create(nullptr, Format_R8G8B8A8_UNORM, uvec2(1), 1, 6,
			SampleCount_1, ImageUsageTransferDst | ImageUsageSampled, true));
		img_black_cube->clear(ImageLayoutUndefined, ImageLayoutShaderReadOnly, cvec4(0, 0, 0, 255));

		auto iv_white = img_white->get_view();
		auto iv_black = img_black->get_view();
		auto iv_black_cube = img_black_cube->get_view({ 0, 1, 0, 6 });

		auto& ed = *_ed;

		ed.pl_element = Pipeline::get(nullptr, L"element/element.pipeline");

		ed.buf_vtx.create(BufferUsageVertex, 360000);
		ed.buf_idx.create(BufferUsageIndex, 240000);
		ed.ds_element.reset(DescriptorSet::create(nullptr, DescriptorSetLayout::get(nullptr, L"element/element.dsl")));
		ed.reses.resize(element::DSL_element::images_count);
		for (auto i = 0; i < ed.reses.size(); i++)
		{
			ed.ds_element->set_image(element::DSL_element::images_binding, i, iv_white, sp_linear);
			ed.reses[i] = iv_white;
		}
		ed.ds_element->update();

		auto& nd = *_nd;

		nd.tex_reses.resize(DSL_material::maps_count);
		nd.mat_reses.resize(MaxMatCount);
		nd.mesh_reses.resize(128);

		for (auto& v : nd.meshes)
			v.resize(MaxMatCount);

		for (auto& b : nd.buf_mesh_indirs)
			b.create(BufferUsageIndirect, 65536);

		{
			auto& dst = nd.mat_reses[MaterialWireframe];
			dst.mat = (Material*)INVALID_POINTER;
			dst.pipeline_file = L"standard_mataterial.glsl";
			dst.pipeline_defines.push_back("WIREFRAME");
		}
		{
			auto& dst = nd.mat_reses[MaterialOutline];
			dst.mat = (Material*)INVALID_POINTER;
			dst.pipeline_file = L"standard_mataterial.glsl";
			dst.pipeline_defines.push_back("OUTLINE");
		}
		{
			auto& dst = nd.mat_reses[MaterialPickup];
			dst.mat = (Material*)INVALID_POINTER;
			dst.pipeline_file = L"standard_mataterial.glsl";
			dst.pipeline_defines.push_back("PICKUP");
		}
		{
			auto& dst = nd.mat_reses[MaterialNormalData];
			dst.mat = (Material*)INVALID_POINTER;
			dst.pipeline_file = L"standard_mataterial.glsl";
			dst.pipeline_defines.push_back("NORMAL_DATA");
		}

		nd.buf_mesh_vtx.create(BufferUsageVertex, 2000000);
		nd.buf_mesh_idx.create(BufferUsageIndex, 2000000);
		nd.buf_arm_mesh_vtx.create(BufferUsageVertex, 2000000);
		nd.buf_arm_mesh_idx.create(BufferUsageIndex, 2000000);
		nd.buf_ptc_vtx.create(BufferUsageVertex, 10000);

		nd.buf_lines.create(BufferUsageVertex, 2000000);

		nd.buf_render_data.create(BufferUsageUniform);
		{
			auto& data = *nd.buf_render_data.pstag;
			data.fog_color = vec3(0.f);
			data.sky_intensity = 0.2f;
			data.sky_rad_levels = 0;
		}
		nd.ds_render_data.reset(DescriptorSet::create(nullptr, DescriptorSetLayout::get(nullptr, L"scene.dsl")));
		nd.ds_render_data->set_buffer(DSL_render_data::RenderData_binding, 0, nd.buf_render_data.buf.get());
		nd.ds_render_data->update();

		nd.buf_materials.create(BufferUsageStorage);
		nd.ds_material.reset(DescriptorSet::create(nullptr, DescriptorSetLayout::get(nullptr, L"material.dsl")));
		nd.ds_material->set_buffer(DSL_material::MaterialInfos_binding, 0, nd.buf_materials.buf.get());
		for (auto i = 0; i < nd.tex_reses.size(); i++)
			nd.ds_material->set_image(DSL_material::maps_binding, i, iv_white, sp_linear);
		nd.ds_material->update();

		nd.buf_mesh_transforms.create(BufferUsageStorage);
		nd.buf_mesh_armatures.create(BufferUsageStorage);
		assert(_countof(mesh::DSL_mesh::Armature::bones) == ArmatureMaxBones);
		nd.ds_mesh.reset(DescriptorSet::create(nullptr, DescriptorSetLayout::get(nullptr, L"mesh/mesh.dsl")));
		nd.ds_mesh->set_buffer(mesh::DSL_mesh::Transforms_binding, 0, nd.buf_mesh_transforms.buf.get());
		nd.ds_mesh->set_buffer(mesh::DSL_mesh::Armatures_binding, 0, nd.buf_mesh_armatures.buf.get());
		nd.ds_mesh->update();

		nd.buf_terrain.create(BufferUsageStorage);
		nd.ds_terrain.reset(DescriptorSet::create(nullptr, DescriptorSetLayout::get(nullptr, L"terrain/terrain.dsl")));
		nd.ds_terrain->set_buffer(terrain::DSL_terrain::TerrainInfos_binding, 0, nd.buf_terrain.buf.get());
		nd.ds_terrain->update();

		nd.buf_water.create(BufferUsageStorage);
		nd.ds_water.reset(DescriptorSet::create(nullptr, DescriptorSetLayout::get(nullptr, L"water/water.dsl")));
		nd.ds_water->set_buffer(water::DSL_water::WaterInfos_binding, 0, nd.buf_water.buf.get());
		nd.ds_water->update();

		nd.buf_light_infos.create(BufferUsageStorage);
		nd.buf_tile_lights.create(BufferUsageStorage);
		nd.buf_dir_shadows.create(BufferUsageStorage);
		nd.buf_pt_shadows.create(BufferUsageStorage);
		nd.img_dir_shadow_maps.resize(DSL_light::dir_shadow_maps_count);
		for (auto i = 0; i < nd.img_dir_shadow_maps.size(); i++)
		{
			nd.img_dir_shadow_maps[i].reset(Image::create(nullptr, Format_Depth16, shadow_map_size, 1, 4,
				SampleCount_1, ImageUsageSampled | ImageUsageAttachment));
			nd.img_dir_shadow_maps[i]->change_layout(ImageLayoutUndefined, ImageLayoutShaderReadOnly);
		}
		nd.img_pt_shadow_maps.resize(DSL_light::pt_shadow_maps_count);
		for (auto i = 0; i < nd.img_pt_shadow_maps.size(); i++)
		{
			nd.img_pt_shadow_maps[i].reset(Image::create(nullptr, Format_Depth16, vec2(shadow_map_size) * 0.5f, 1, 6,
				SampleCount_1, ImageUsageSampled | ImageUsageAttachment, true));
			nd.img_pt_shadow_maps[i]->change_layout(ImageLayoutUndefined, ImageLayoutShaderReadOnly);
		}
		nd.ds_light.reset(DescriptorSet::create(nullptr, DescriptorSetLayout::get(nullptr, L"light.dsl")));
		nd.ds_light->set_buffer(DSL_light::LightInfos_binding, 0, nd.buf_light_infos.buf.get());
		nd.ds_light->set_buffer(DSL_light::TileLightsMap_binding, 0, nd.buf_tile_lights.buf.get());
		nd.ds_light->set_buffer(DSL_light::DirShadows_binding, 0, nd.buf_dir_shadows.buf.get());
		nd.ds_light->set_buffer(DSL_light::PtShadows_binding, 0, nd.buf_pt_shadows.buf.get());
		auto sp_shadow = Sampler::get(nullptr, FilterLinear, FilterLinear, false, AddressClampToBorder);
		for (auto i = 0; i < nd.img_dir_shadow_maps.size(); i++)
		{
			auto iv = nd.img_dir_shadow_maps[i]->get_view({ 0, 1, 0, 4 });
			nd.ds_light->set_image(DSL_light::dir_shadow_maps_binding, i, iv, sp_shadow);
		}
		for (auto i = 0; i < nd.img_pt_shadow_maps.size(); i++)
		{
			auto iv = nd.img_pt_shadow_maps[i]->get_view({ 0, 1, 0, 6 });
			nd.ds_light->set_image(DSL_light::pt_shadow_maps_binding, i, iv, sp_shadow);
		}
		nd.ds_light->set_image(DSL_light::sky_box_binding, 0, iv_black_cube, sp_linear);
		nd.ds_light->set_image(DSL_light::sky_irr_binding, 0, iv_black_cube, sp_linear);
		nd.ds_light->set_image(DSL_light::sky_rad_binding, 0, iv_black_cube, sp_linear);
		nd.ds_light->set_image(DSL_light::sky_lut_binding, 0, iv_black, sp_linear);
		nd.ds_light->update();

		nd.pll_mesh_fwd = PipelineLayout::get(nullptr, L"mesh/forward.pll");
		nd.pll_mesh_gbuf = PipelineLayout::get(nullptr, L"mesh/gbuffer.pll");
		nd.pll_terrain_fwd = PipelineLayout::get(nullptr, L"terrain/forward.pll");
		nd.pll_terrain_gbuf = PipelineLayout::get(nullptr, L"terrain/gbuffer.pll");
		nd.pll_water = PipelineLayout::get(nullptr, L"water/water.pll");
		nd.pll_post = PipelineLayout::get(nullptr, L"post/post.pll");

		std::uniform_real_distribution<float> r(0.f, 1.f);
		std::default_random_engine rd;

		nd.buf_ssao_loc.create(BufferUsageUniform);
		{
			auto& data = *nd.buf_ssao_loc.pstag;
			for (auto i = 0; i < _countof(data.sample_locations); i++)
			{
				vec3 sample(r(rd) * 2.f - 1.f, r(rd), r(rd) * 2.f - 1.f);
				sample = normalize(sample) * r(rd);

				auto scale = float(i) / _countof(data.sample_locations);
				scale = lerp(0.1f, 1.f, scale * scale);
				sample *= scale;
				data.sample_locations[i] = vec4(sample, 0.f);
			}

			nd.buf_ssao_loc.cpy_whole();
			nd.buf_ssao_loc.upload(cb.get());
		}
		nd.buf_ssao_noi.create(BufferUsageUniform);
		{
			auto& data = *nd.buf_ssao_noi.pstag;
			for (auto i = 0; i < _countof(data.sample_noises); i++)
				data.sample_noises[i] = vec4(normalize(vec3(r(rd) * 2.f - 1.f, 0.f, r(rd) * 2.f - 1.f)), 0.f);

			nd.buf_ssao_noi.cpy_whole();
			nd.buf_ssao_noi.upload(cb.get());
		}
		nd.pl_ssao = Pipeline::get(nullptr, L"deferred/ssao.pipeline");
		nd.pl_ssao_blur = Pipeline::get(nullptr, L"deferred/ssao_blur.pipeline");
		nd.ds_ssao.reset(DescriptorSet::create(nullptr, DescriptorSetLayout::get(nullptr, L"deferred/ssao.dsl")));
		nd.ds_ssao->set_buffer(DSL_ssao::SampleLocations_binding, 0, nd.buf_ssao_loc.buf.get());
		nd.ds_ssao->set_buffer(DSL_ssao::SampleNoises_binding, 0, nd.buf_ssao_noi.buf.get());
		nd.ds_ssao->update();

		nd.pl_def = Pipeline::get(nullptr, L"deferred/deferred.pipeline");
		nd.ds_def.reset(DescriptorSet::create(nullptr, DescriptorSetLayout::get(nullptr, L"deferred/deferred.dsl")));

		nd.pl_ptc = Pipeline::get(nullptr, L"particle/particle.pipeline");

		nd.pl_line = Pipeline::get(nullptr, L"plain/line.pipeline");

		nd.pl_blit_rgba8 = Pipeline::get(nullptr, L"post/blit_rgba8.pipeline");
		nd.pl_blit_rgba16 = Pipeline::get(nullptr, L"post/blit_rgba16.pipeline");
		nd.pl_blit_rgba16ms4 = Pipeline::get(nullptr, L"post/blit_rgba16ms4.pipeline");
		nd.pl_blit_d16 = Pipeline::get(nullptr, L"post/blit_d16.pipeline");
		nd.pl_blit_d16ms4 = Pipeline::get(nullptr, L"post/blit_d16ms4.pipeline");
		nd.pl_add_bgra8 = Pipeline::get(nullptr, L"post/add_bgra8.pipeline");
		nd.pl_add_rgba8 = Pipeline::get(nullptr, L"post/add_rgba8.pipeline");
		nd.pl_add_rgba16 = Pipeline::get(nullptr, L"post/add_rgba16.pipeline");
		nd.pl_fxaa = Pipeline::get(nullptr, L"post/fxaa.pipeline");
		nd.pl_downsample = Pipeline::get(nullptr, L"post/downsample.pipeline");
		nd.pl_upsample = Pipeline::get(nullptr, L"post/upsample.pipeline");

		nd.buf_lum_htg.create(BufferUsageStorage);
		nd.buf_lum_avg.create(BufferUsageStorage);
		nd.ds_lum.reset(DescriptorSet::create(nullptr, DescriptorSetLayout::get(nullptr, L"post/luminance.dsl")));
		nd.ds_lum->set_buffer(DSL_luminance::Histogram_binding, 0, nd.buf_lum_htg.buf.get());
		nd.ds_lum->set_buffer(DSL_luminance::AverageLum_binding, 0, nd.buf_lum_avg.buf.get());
		nd.ds_lum->update();
		nd.pll_lum = PipelineLayout::get(nullptr, L"post/luminance.pll");
		nd.pl_lum_htg = Pipeline::get(nullptr, L"post/luminance_histogram.pipeline");
		nd.pl_lum_avg = Pipeline::get(nullptr, L"post/luminance_average.pipeline");

		nd.pl_bright = Pipeline::get(nullptr, L"post/bright.pipeline");

		nd.ds_tone.reset(DescriptorSet::create(nullptr, DescriptorSetLayout::get(nullptr, L"post/tone.dsl")));
		nd.ds_tone->set_buffer(DSL_tone::AverageLum_binding, 0, nd.buf_lum_avg.buf.get());
		nd.ds_tone->update();
		nd.pl_tone = Pipeline::get(nullptr, L"post/tone.pipeline");
	}

	void sRendererPrivate::update()
	{
		if (always_update)
			dirty = true;
		if (fb_tars.empty() || !dirty)
			return;

		if (window)
			window->mark_dirty();
	}

	sRenderer* sRenderer::create()
	{
		return new sRendererPrivate(parms);
	}
}
