# Flame Game Engine
An ECS Game Engine Based On Reflection.

# Requirements:

- VisualStudio

- VulkanSDK     - https://vulkan.lunarg.com/sdk/home#windows

# Build:

- cmake flame

- install Vulkan and OpenAL SDK

- run ./set_env.bat (you need to restart your IDE to take that effect)

- regsvr32 msdia140.dll in visual studio's dia sdk i.e. "vs_path/DIA SDK/bin/amd64"

- build

(if you want to build in release config, always build in RelWithDebInfo, because DebugInfo is always needed)

more details please see doc/01.build.md

# Reflection:

#### How It Works:

The typeinfo is generated by the help of DIA SDK, which is a tool to inspect the pdb files. This tool is powerful and it is provided with the visual studio. The generation is done by a tool called typeinfogen of this project, which will be called after the target built. All of the libraries (except foundation) and some tools/tests in this project are reflected in this way. You can generate your project's typeinfo by just call the typeinfogen with your project's executable's path.
The typeinfogen wouldn't reflect all informations in the target. The desired items should be marked in the source file. Here's how it works:

        struct cElement : Component // R !ctor !dtor !type_name !type_hash
        {
        }
    
First, the R symbol in the comment means this struct/class, variable or function in this line is marked reflected. Next, it follows some tokens that descrips more of the reflection. By default, the R in the struct/class suggested that it will reflect all members of that struct/class (the opposite is R ~), and any tokens begin will '!' suggested that this member will not be reflected. You can define you own token usages, all tokens can be retrieve by calling the get_token() function of VariableInfo. Tokens can have value, simply place a '=' after that token, such as 'max_value=100'. You can make use of the tokens as you like, such as the slider min/max value, speed and so on.

#### Engine Use Cases:

Currently, the engine uses the typeinfo to do such things:

- With the help of refelcted function address (or the virtual table offset), we can call any reflected functions, and we can create or destroy any reflected struct/class.

- Use for serialization objects.

- Use to call functions from script.

- Describe the requirements of a component. For example:

        struct cSliderPrivate : cSlider // R ~ on_*
	    {
            ...
		    cElementPrivate* bar_element = nullptr; // R ref place=bar
		    cElementPrivate* thumb_element = nullptr; // R ref place=thumb
		    cEventReceiverPrivate* thumb_event_receiver = nullptr; // R ref place=thumb
		    cTextPrivate* text = nullptr; // R ref place=text
            ...
		    void on_gain_bar_element();
		    void on_lost_bar_element();

		    void on_gain_thumb_event_receiver();
		    void on_lost_thumb_event_receiver();
	    };
 This component defines five requirements, each is another component in somewhere. If those requirements cannot be satisfied, the component cannot be added to entity or the entity contains that component cannot be added to another entity.
 
# Scene Serialization:

Scene can be load/save using the prefab file (xml format), including the ui. Yes ui is under the ecs as other game objects!

Here is an example of the scene file:

	<?xml version="1.0"?>
	<prefab>
	  <entity src="hsplitter" >
	    <cAligner alignx="MinMax" aligny="MinMax" />
	    <cLayout auto_width="false" auto_height="false" />
	    <entity>
	      <cElement/>
	      <cAligner alignx="MinMax" aligny="MinMax" />
	      <cLayout type="Vertical" auto_width="false" auto_height="false" />
	      <entity name="search" src="edit" >
		<cAligner alignx="MinMax" />
	      </entity>
	      <entity src="vscroller" >
		<cElement padding="4,4,4,4" border="1" />
		<cAligner alignx="MinMax" aligny="MinMax" />
		<entity attach="view" name="tree" src="tree">
		  <cElement padding="4,4,4,4" />
		  <cAligner alignx="MinMax" />
		</entity>
	      </entity>
	    </entity>
	    <entity src="scroller">
	      <cElement />
	      <cAligner alignx="MinMax" aligny="MinMax" />
	      <entity attach="view" name="image">
		<cElement />
		<cImage />
		<cAligner />
	      </entity>
	    </entity>
	  </entity>
	</prefab>
	
Which describes an ui like this:

![prefab_example](https://raw.githubusercontent.com/tkgamegroup/flame/master/screenshots/prefab_example.png)

# Script:

Currently, we use lua as the script language. With the help of reflection, we can pass the function infos to the lua side, then lua can pass back that function info with arguments to call the cpp function. We just register a handful functions to lua. And we can call arbitrary cpp function through some asm magic (this magic is also used to call a setter function). To use scripts are very simple, just like:

The prefab file:

	<?xml version="1.0"?>
	<prefab>
	  <entity src="button">
	    <cScript src="tests/button_test.lua" />
	  </entity>
	</prefab>
	
The lua file:

	local event_receiver = entity:get_component_n("cEventReceiver")
	make_obj(event_receiver, "cEventReceiver")

	event_receiver:add_mouse_click_listener_s(get_slot(
		function()
			print("Hello World")
		end
	))
